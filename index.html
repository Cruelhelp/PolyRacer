<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>POLY RACE: Multiplayer Racing</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700&display=swap" rel="stylesheet">
  <script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    html, body {
      height: 100%;
      width: 100%;
      overflow: hidden;
      background: #000;
      font-family: 'Orbitron', sans-serif;
    }

    canvas {
      width: 100vw;
      height: 100vh;
      display: block;
      background: #000;
    }

    /* Main Menu */
    #main-menu {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.95);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
    }

    #main-menu.hidden {
      display: none;
    }

    .menu-content {
      background: linear-gradient(135deg, #020208, #080010);
      border: 2px solid #00ffff;
      border-radius: 12px;
      padding: 40px;
      max-width: 500px;
      width: 90%;
      box-shadow: 0 0 50px rgba(0, 255, 255, 0.5);
      text-align: center;
    }

    .menu-title {
      font-size: 42px;
      color: #00ffff;
      margin-bottom: 10px;
      text-shadow: 0 0 20px #00ffff;
      letter-spacing: 3px;
    }

    .menu-subtitle {
      font-size: 16px;
      color: #ff00ff;
      margin-bottom: 30px;
      letter-spacing: 2px;
    }

    .menu-buttons {
      display: flex;
      flex-direction: column;
      gap: 15px;
      margin-bottom: 20px;
    }

    .menu-btn {
      padding: 18px;
      background: linear-gradient(135deg, rgba(0, 255, 255, 0.3), rgba(0, 255, 136, 0.3));
      border: 2px solid #00ffff;
      border-radius: 8px;
      color: #00ffff;
      font-family: 'Orbitron', sans-serif;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .menu-btn:hover:not(:disabled) {
      background: linear-gradient(135deg, rgba(0, 255, 255, 0.5), rgba(0, 255, 136, 0.5));
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
      transform: translateY(-2px);
    }

    .menu-btn.secondary {
      background: linear-gradient(135deg, rgba(255, 0, 255, 0.2), rgba(138, 0, 255, 0.2));
      border-color: #ff00ff;
      color: #ff00ff;
    }

    .menu-btn.secondary:hover:not(:disabled) {
      background: linear-gradient(135deg, rgba(255, 0, 255, 0.3), rgba(138, 0, 255, 0.3));
      box-shadow: 0 0 30px rgba(255, 0, 255, 0.4);
    }

    .player-info {
      margin-top: 20px;
      padding: 15px;
      background: rgba(0, 0, 0, 0.5);
      border: 1px solid rgba(0, 255, 255, 0.3);
      border-radius: 8px;
    }

    .player-info-label {
      font-size: 12px;
      color: rgba(0, 255, 255, 0.6);
      margin-bottom: 5px;
    }

    .player-info-value {
      font-size: 16px;
      color: #00ffff;
      font-weight: bold;
    }

    .player-info-edit {
      margin-top: 10px;
      display: flex;
      gap: 10px;
    }

    .player-info-input {
      flex: 1;
      padding: 10px;
      background: rgba(0, 0, 0, 0.5);
      border: 1px solid rgba(0, 255, 255, 0.3);
      border-radius: 4px;
      color: #00ffff;
      font-family: 'Orbitron', sans-serif;
      font-size: 14px;
      text-align: center;
      outline: none;
    }

    .player-info-input:focus {
      border-color: #00ffff;
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
    }

    .player-info-btn {
      padding: 10px 15px;
      background: rgba(0, 255, 255, 0.2);
      border: 1px solid #00ffff;
      border-radius: 4px;
      color: #00ffff;
      font-family: 'Orbitron', sans-serif;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .player-info-btn:hover {
      background: rgba(0, 255, 255, 0.3);
    }

    /* Connection Status */
    #connection-status {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.8);
      border: 2px solid #00ffff;
      border-radius: 8px;
      padding: 12px 20px;
      z-index: 1000;
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 12px;
      color: #00ffff;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .status-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      animation: pulse 2s infinite;
    }

    .status-dot.connected { background: #00ff88; box-shadow: 0 0 10px #00ff88; }
    .status-dot.disconnected { background: #ff0000; box-shadow: 0 0 10px #ff0000; animation: none; }
    .status-dot.connecting { background: #ff00ff; box-shadow: 0 0 10px #ff00ff; }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    /* Game HUD */
    #game-hud {
      position: fixed;
      top: 20px;
      left: 20px;
      color: #fff;
      z-index: 100;
      font-size: 14px;
    }

    .hud-item {
      background: rgba(0, 0, 0, 0.7);
      border: 1px solid rgba(0, 255, 255, 0.3);
      border-radius: 6px;
      padding: 8px 15px;
      margin-bottom: 8px;
    }

    .hud-label {
      font-size: 10px;
      color: rgba(0, 255, 255, 0.6);
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .hud-value {
      font-size: 16px;
      color: #00ffff;
      font-weight: bold;
      text-shadow: 0 0 10px #00ffff;
    }

    /* Room UI */
    #room-ui {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(2, 2, 8, 0.95);
      border: 2px solid #00ffff;
      border-radius: 12px;
      padding: 30px;
      z-index: 500;
      min-width: 400px;
      display: none;
    }

    #room-ui.visible {
      display: block;
    }

    .room-title {
      font-size: 24px;
      color: #00ffff;
      text-align: center;
      margin-bottom: 20px;
      text-shadow: 0 0 20px #00ffff;
      letter-spacing: 2px;
    }

    .room-code {
      background: rgba(0, 255, 255, 0.1);
      border: 1px solid rgba(0, 255, 255, 0.3);
      border-radius: 6px;
      padding: 15px;
      text-align: center;
      margin-bottom: 20px;
    }

    .room-code-label {
      font-size: 10px;
      color: rgba(0, 255, 255, 0.6);
      margin-bottom: 5px;
    }

    .room-code-value {
      font-size: 28px;
      color: #00ffff;
      font-weight: bold;
      letter-spacing: 4px;
      text-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
    }

    .room-players {
      margin: 20px 0;
    }

    .room-player {
      background: rgba(0, 255, 255, 0.05);
      border: 1px solid rgba(0, 255, 255, 0.2);
      border-radius: 6px;
      padding: 12px;
      margin-bottom: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .room-player-name {
      color: #00ffff;
      font-size: 14px;
      font-weight: bold;
    }

    .room-player-status {
      font-size: 11px;
      padding: 4px 12px;
      border-radius: 4px;
      text-transform: uppercase;
    }

    .room-player-status.ready {
      background: rgba(0, 255, 136, 0.3);
      color: #00ff88;
      border: 1px solid #00ff88;
    }

    .room-player-status.waiting {
      background: rgba(255, 0, 255, 0.3);
      color: #ff00ff;
      border: 1px solid #ff00ff;
    }

    .room-btn {
      width: 100%;
      padding: 15px;
      background: linear-gradient(135deg, rgba(0, 255, 255, 0.3), rgba(0, 255, 136, 0.3));
      border: 2px solid #00ffff;
      border-radius: 8px;
      color: #00ffff;
      font-family: 'Orbitron', sans-serif;
      font-size: 14px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 2px;
      margin-top: 10px;
    }

    .room-btn:hover:not(:disabled) {
      background: linear-gradient(135deg, rgba(0, 255, 255, 0.5), rgba(0, 255, 136, 0.5));
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
    }

    .room-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .room-btn.secondary {
      background: linear-gradient(135deg, rgba(255, 0, 255, 0.2), rgba(138, 0, 255, 0.2));
      border-color: #ff00ff;
      color: #ff00ff;
    }

    .room-btn.secondary:hover:not(:disabled) {
      background: linear-gradient(135deg, rgba(255, 0, 255, 0.3), rgba(138, 0, 255, 0.3));
      box-shadow: 0 0 30px rgba(255, 0, 255, 0.4);
    }

    /* Notifications */
    .notification {
      position: fixed;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.9);
      border: 2px solid;
      border-radius: 8px;
      padding: 15px 30px;
      font-size: 14px;
      font-weight: bold;
      z-index: 10000;
      animation: slideDown 0.3s ease;
    }

    @keyframes slideDown {
      from { transform: translate(-50%, -20px); opacity: 0; }
      to { transform: translate(-50%, 0); opacity: 1; }
    }

    /* Practice Mode UI */
    #practice-mode-ui {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(2, 2, 8, 0.95);
      border: 2px solid #00ffff;
      border-radius: 12px;
      padding: 30px;
      z-index: 500;
      min-width: 400px;
      display: none;
      text-align: center;
    }

    #practice-mode-ui.visible {
      display: block;
    }

    .practice-title {
      font-size: 24px;
      color: #00ffff;
      text-align: center;
      margin-bottom: 20px;
      text-shadow: 0 0 20px #00ffff;
      letter-spacing: 2px;
    }

    .practice-instructions {
      color: #ff00ff;
      margin-bottom: 30px;
      line-height: 1.5;
    }

    .practice-stats {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
      margin-bottom: 30px;
    }

    .practice-stat {
      background: rgba(0, 255, 255, 0.1);
      border: 1px solid rgba(0, 255, 255, 0.3);
      border-radius: 6px;
      padding: 15px;
    }

    .practice-stat-label {
      font-size: 12px;
      color: rgba(0, 255, 255, 0.6);
      margin-bottom: 5px;
    }

    .practice-stat-value {
      font-size: 24px;
      color: #00ffff;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <!-- Main Menu -->
  <div id="main-menu">
    <div class="menu-content">
      <div class="menu-title">POLY RACE</div>
      <div class="menu-subtitle">MULTIPLAYER KEYBOARD RACING</div>
      
      <div class="menu-buttons">
        <button class="menu-btn" id="create-room-btn">CREATE ROOM</button>
        <button class="menu-btn" id="join-room-btn">JOIN ROOM</button>
        <button class="menu-btn secondary" id="random-match-btn">RANDOM MATCH</button>
        <button class="menu-btn secondary" id="practice-btn">PRACTICE MODE</button>
      </div>
      
      <div class="player-info">
        <div class="player-info-label">PLAYER NAME</div>
        <div class="player-info-value" id="player-name-display">Racer #---</div>
        <div class="player-info-edit">
          <input type="text" class="player-info-input" id="player-name-input" placeholder="Enter custom name" maxlength="15">
          <button class="player-info-btn" id="player-name-submit">UPDATE</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Connection Status -->
  <div id="connection-status">
    <div class="status-dot connecting"></div>
    <span id="connection-text">Connecting...</span>
  </div>

  <!-- Game HUD -->
  <div id="game-hud" style="display: none;">
    <div class="hud-item">
      <div class="hud-label">Your Name</div>
      <div class="hud-value" id="hud-player-name">---</div>
    </div>
    <div class="hud-item">
      <div class="hud-label">Room Code</div>
      <div class="hud-value" id="hud-room-code">---</div>
    </div>
  </div>

  <!-- Room UI -->
  <div id="room-ui">
    <div class="room-title" id="room-title">WAITING FOR PLAYERS</div>

    <div class="room-code">
      <div class="room-code-label">ROOM CODE</div>
      <div class="room-code-value" id="display-room-code">------</div>
    </div>

    <div class="room-players" id="room-players-list">
      <!-- Players will be added here dynamically -->
    </div>

    <button class="room-btn" id="ready-btn">I'M READY</button>
    <button class="room-btn secondary" id="leave-room-btn">LEAVE ROOM</button>
  </div>

  <!-- Practice Mode UI -->
  <div id="practice-mode-ui">
    <div class="practice-title">PRACTICE MODE</div>
    <div class="practice-instructions">
      Press the highlighted keys to move forward!<br>
      Try to reach the finish line as fast as possible.
    </div>
    
    <div class="practice-stats">
      <div class="practice-stat">
        <div class="practice-stat-label">BEST TIME</div>
        <div class="practice-stat-value" id="practice-best-time">--.--s</div>
      </div>
      <div class="practice-stat">
        <div class="practice-stat-label">BEST SCORE</div>
        <div class="practice-stat-value" id="practice-best-score">---</div>
      </div>
    </div>
    
    <button class="room-btn" id="practice-start-btn">START PRACTICE</button>
    <button class="room-btn secondary" id="practice-back-btn">BACK TO MENU</button>
  </div>

  <canvas id="game-canvas"></canvas>

  <script>
    // =======================================
    // GAME STATE & SOCKET CONNECTION
    // =======================================
    let socket = null;
    let myPlayerId = null;
    let myPlayerName = null;
    let currentRoom = null;
    let gameState = 'menu'; // menu, waiting, countdown, playing, finished, practice

    // Practice mode stats
    let practiceBestTime = localStorage.getItem('practiceBestTime') || null;
    let practiceBestScore = localStorage.getItem('practiceBestScore') || 0;

    // Connect to server
    function initSocket() {
      const serverUrl = window.location.origin;
      socket = io(serverUrl);

      socket.on('connect', () => {
        console.log('Connected to server:', socket.id);
        updateConnectionStatus('connected');
        
        // Auto-generate a player name if not set
        if (!myPlayerId) {
          const randomId = Math.floor(Math.random() * 10000);
          myPlayerId = socket.id;
          myPlayerName = `Racer #${randomId}`;
          updatePlayerNameDisplay();
          
          // Register with the generated name
          socket.emit('player:register', { name: myPlayerName });
        }
      });

      socket.on('disconnect', () => {
        console.log('Disconnected');
        updateConnectionStatus('disconnected');
        showNotification('Disconnected from server', '#ff0000');
      });

      socket.on('connect_error', () => {
        updateConnectionStatus('disconnected');
      });

      // Player registered
      socket.on('player:registered', (data) => {
        myPlayerId = data.playerId;
        myPlayerName = data.playerData.name;
        updatePlayerNameDisplay();
        console.log('Registered as:', myPlayerName);
      });

      // Room created
      socket.on('room:created', (data) => {
        currentRoom = data.room;
        hideMainMenu();
        showRoomUI(data.room);
      });

      // Room joined
      socket.on('room:joined', (data) => {
        currentRoom = data.room;
        hideMainMenu();
        showRoomUI(data.room);
      });

      // Room updated
      socket.on('room:updated', (data) => {
        currentRoom = data.room;
        updateRoomUI(data.room);
      });

      // Match found
      socket.on('match:found', (data) => {
        currentRoom = data.room;
        hideMainMenu();
        showRoomUI(data.room);
      });

      // Game countdown
      socket.on('game:countdown', (data) => {
        gameState = 'countdown';
        startCountdown();
      });

      // Game start
      socket.on('game:start', (data) => {
        gameState = 'playing';
        hideRoomUI();
        startGame();
      });

      // Game update (other players)
      socket.on('game:update', (data) => {
        updateOpponentStates(data.players);
      });

      // Game finished
      socket.on('game:finished', (data) => {
        gameState = 'finished';
        showWinner(data.winner);
      });

      // Player left room
      socket.on('room:player-left', (data) => {
        showNotification(`${data.playerName} left the room`, '#ff00ff');
        if (data.room) {
          currentRoom = data.room;
          updateRoomUI(data.room);
        }
      });

      // Room error
      socket.on('room:error', (data) => {
        showNotification(data.message, '#ff0000');
      });
    }

    // =======================================
    // MAIN MENU UI
    // =======================================
    function updateConnectionStatus(status) {
      const dot = document.querySelector('.status-dot');
      const text = document.getElementById('connection-text');

      dot.className = `status-dot ${status}`;

      const messages = {
        connected: 'Connected to Railway',
        disconnected: 'Offline',
        connecting: 'Connecting...'
      };

      text.textContent = messages[status] || 'Unknown';
    }

    function updatePlayerNameDisplay() {
      document.getElementById('player-name-display').textContent = myPlayerName;
      document.getElementById('hud-player-name').textContent = myPlayerName;
    }

    function hideMainMenu() {
      document.getElementById('main-menu').classList.add('hidden');
    }

    function showMainMenu() {
      document.getElementById('main-menu').classList.remove('hidden');
    }

    // Menu button handlers
    document.getElementById('create-room-btn').addEventListener('click', () => {
      if (!socket || !socket.connected) {
        showNotification('Not connected to server', '#ff0000');
        return;
      }
      socket.emit('room:create');
    });

    document.getElementById('join-room-btn').addEventListener('click', () => {
      if (!socket || !socket.connected) {
        showNotification('Not connected to server', '#ff0000');
        return;
      }
      const code = prompt('Enter room code:');
      if (code) {
        socket.emit('room:join', { roomCode: code.toUpperCase() });
      }
    });

    document.getElementById('random-match-btn').addEventListener('click', () => {
      if (!socket || !socket.connected) {
        showNotification('Not connected to server', '#ff0000');
        return;
      }
      socket.emit('match:random');
      showNotification('Searching for opponent...', '#ff00ff');
    });

    document.getElementById('practice-btn').addEventListener('click', () => {
      showPracticeModeUI();
    });

    // Player name update
    document.getElementById('player-name-submit').addEventListener('click', () => {
      const input = document.getElementById('player-name-input');
      const newName = input.value.trim();
      
      if (newName.length < 2) {
        showNotification('Name must be at least 2 characters', '#ff0000');
        return;
      }
      
      myPlayerName = newName;
      updatePlayerNameDisplay();
      input.value = '';
      
      // Update on server if connected
      if (socket && socket.connected) {
        socket.emit('player:update-name', { name: newName });
      }
      
      showNotification('Name updated!', '#00ff88');
    });

    // Allow Enter key to submit name
    document.getElementById('player-name-input').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        document.getElementById('player-name-submit').click();
      }
    });

    // =======================================
    // PRACTICE MODE
    // =======================================
    function showPracticeModeUI() {
      hideMainMenu();
      document.getElementById('practice-mode-ui').classList.add('visible');
      
      // Update practice stats
      document.getElementById('practice-best-time').textContent = 
        practiceBestTime ? `${practiceBestTime}s` : '--.--s';
      document.getElementById('practice-best-score').textContent = practiceBestScore;
    }

    function hidePracticeModeUI() {
      document.getElementById('practice-mode-ui').classList.remove('visible');
    }

    function startPracticeMode() {
      gameState = 'practice';
      hidePracticeModeUI();
      
      // Reset game state
      resizeCanvas();
      myPosition = canvas.width * 0.1;
      myProgress = 0;
      myScore = 0;
      myCombo = 0;
      myNextKey = getRandomKey();
      raceStartTime = Date.now();

      // Start game loop
      practiceGameLoop();

      // Add keyboard listener
      document.addEventListener('keydown', handlePracticeKeyPress);
    }

    function handlePracticeKeyPress(e) {
      if (gameState !== 'practice') return;

      const key = e.key.toLowerCase();

      if (key === myNextKey) {
        // Correct key!
        myPosition += canvas.width * 0.05; // Move forward
        myScore += 10;
        myCombo++;
        myNextKey = getRandomKey();

        // Calculate progress (0 to 1)
        const startX = canvas.width * 0.1;
        const finishX = canvas.width * FINISH_LINE;
        myProgress = Math.min(1, (myPosition - startX) / (finishX - startX));

        // Check if finished
        if (myProgress >= 1) {
          finishPracticeRace();
        }
      } else if (KEYS.includes(key)) {
        // Wrong key
        myCombo = 0;
      }
    }

    function finishPracticeRace() {
      gameState = 'finished';
      const raceTime = ((Date.now() - raceStartTime) / 1000).toFixed(2);

      // Update best stats
      if (!practiceBestTime || parseFloat(raceTime) < parseFloat(practiceBestTime)) {
        practiceBestTime = raceTime;
        localStorage.setItem('practiceBestTime', practiceBestTime);
      }
      
      if (myScore > practiceBestScore) {
        practiceBestScore = myScore;
        localStorage.setItem('practiceBestScore', practiceBestScore);
      }

      document.removeEventListener('keydown', handlePracticeKeyPress);
      
      // Show practice results
      showPracticeResults(raceTime);
    }

    function practiceGameLoop() {
      if (gameState !== 'practice') {
        cancelAnimationFrame(animationFrame);
        return;
      }

      // Clear canvas
      ctx.fillStyle = '#020208';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw grid background
      drawGrid();

      // Draw finish line
      drawFinishLine();

      // Draw my runner
      drawRunner(myPosition, canvas.height * 0.5, '#00ffff', myPlayerName, myNextKey, true);

      // Draw practice HUD
      drawPracticeHUD();

      animationFrame = requestAnimationFrame(practiceGameLoop);
    }

    function drawPracticeHUD() {
      ctx.save();
      ctx.font = 'bold 18px Orbitron';
      ctx.textAlign = 'left';

      // My stats (left side)
      ctx.fillStyle = '#00ffff';
      ctx.shadowColor = '#00ffff';
      ctx.shadowBlur = 15;
      ctx.fillText(`Score: ${myScore}`, 20, canvas.height - 60);
      ctx.fillText(`Combo: x${myCombo}`, 20, canvas.height - 30);

      // Time (right side)
      ctx.textAlign = 'right';
      const currentTime = ((Date.now() - raceStartTime) / 1000).toFixed(2);
      ctx.fillText(`Time: ${currentTime}s`, canvas.width - 20, canvas.height - 60);
      
      // Best time
      if (practiceBestTime) {
        ctx.fillText(`Best: ${practiceBestTime}s`, canvas.width - 20, canvas.height - 30);
      }

      ctx.restore();
    }

    function showPracticeResults(time) {
      cancelAnimationFrame(animationFrame);

      // Draw results overlay
      ctx.save();
      ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.font = 'bold 60px Orbitron';
      ctx.textAlign = 'center';
      ctx.fillStyle = '#00ff88';
      ctx.shadowColor = '#00ff88';
      ctx.shadowBlur = 50;
      ctx.fillText('FINISHED!', canvas.width / 2, canvas.height / 2 - 80);

      ctx.font = 'bold 30px Orbitron';
      ctx.fillStyle = '#ffffff';
      ctx.shadowBlur = 20;
      ctx.fillText(`Time: ${time}s`, canvas.width / 2, canvas.height / 2 - 20);
      ctx.fillText(`Score: ${myScore}`, canvas.width / 2, canvas.height / 2 + 20);

      ctx.font = '20px Orbitron';
      ctx.fillStyle = '#00ffff';
      ctx.fillText('Returning to practice menu in 5 seconds...', canvas.width / 2, canvas.height / 2 + 80);
      ctx.restore();

      setTimeout(() => {
        gameState = 'menu';
        showPracticeModeUI();
      }, 5000);
    }

    // Practice mode controls
    document.getElementById('practice-start-btn').addEventListener('click', () => {
      startPracticeMode();
    });

    document.getElementById('practice-back-btn').addEventListener('click', () => {
      hidePracticeModeUI();
      showMainMenu();
    });

    // =======================================
    // ROOM MANAGEMENT
    // =======================================
    function showRoomUI(room) {
      const roomUI = document.getElementById('room-ui');
      roomUI.classList.add('visible');

      document.getElementById('display-room-code').textContent = room.code;
      document.getElementById('hud-room-code').textContent = room.code;
      document.getElementById('game-hud').style.display = 'block';

      updateRoomUI(room);
    }

    function updateRoomUI(room) {
      const playersList = document.getElementById('room-players-list');
      playersList.innerHTML = '';

      room.players.forEach(player => {
        const div = document.createElement('div');
        div.className = 'room-player';
        div.innerHTML = `
          <div class="room-player-name">${player.name}${player.id === myPlayerId ? ' (You)' : ''}</div>
          <div class="room-player-status ${player.ready ? 'ready' : 'waiting'}">
            ${player.ready ? '✓ Ready' : 'Waiting...'}
          </div>
        `;
        playersList.appendChild(div);
      });

      // Update ready button
      const myPlayer = room.players.find(p => p.id === myPlayerId);
      const readyBtn = document.getElementById('ready-btn');

      if (myPlayer && myPlayer.ready) {
        readyBtn.textContent = '✓ READY';
        readyBtn.disabled = true;
      } else {
        readyBtn.textContent = "I'M READY";
        readyBtn.disabled = false;
      }
    }

    function hideRoomUI() {
      document.getElementById('room-ui').classList.remove('visible');
    }

    // Room controls
    document.getElementById('ready-btn').addEventListener('click', () => {
      socket.emit('player:ready');
    });

    document.getElementById('leave-room-btn').addEventListener('click', () => {
      socket.emit('room:leave');
      hideRoomUI();
      currentRoom = null;
      gameState = 'menu';
      showMainMenu();
    });

    // =======================================
    // NOTIFICATIONS
    // =======================================
    function showNotification(message, color) {
      const notif = document.createElement('div');
      notif.className = 'notification';
      notif.style.borderColor = color;
      notif.style.color = color;
      notif.style.boxShadow = `0 0 30px ${color}40`;
      notif.textContent = message;
      document.body.appendChild(notif);

      setTimeout(() => {
        notif.style.opacity = '0';
        notif.style.transition = 'all 0.3s ease';
        setTimeout(() => notif.remove(), 300);
      }, 3000);
    }

    // =======================================
    // GAME ENGINE
    // =======================================
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    let animationFrame = null;

    // Game variables
    const KEYS = ['a','s','d','f','g','h','j','k','l'];
    let myPosition = 0;
    let myProgress = 0;
    let myScore = 0;
    let myCombo = 0;
    let myNextKey = null;
    let opponentData = null;
    let raceStartTime = 0;
    const FINISH_LINE = 0.75; // 75% of screen width

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }

    function getRandomKey() {
      return KEYS[Math.floor(Math.random() * KEYS.length)];
    }

    function startCountdown() {
      let countdownValue = 3;
      const interval = setInterval(() => {
        if (countdownValue > 0) {
          showNotification(countdownValue.toString(), '#ffffff');
          countdownValue--;
        } else {
          clearInterval(interval);
          showNotification('GO!', '#00ff88');
        }
      }, 1000);
    }

    function startGame() {
      resizeCanvas();

      // Reset game state
      myPosition = canvas.width * 0.1;
      myProgress = 0;
      myScore = 0;
      myCombo = 0;
      myNextKey = getRandomKey();
      raceStartTime = Date.now();

      // Start game loop
      gameLoop();

      // Add keyboard listener
      document.addEventListener('keydown', handleKeyPress);
    }

    function handleKeyPress(e) {
      if (gameState !== 'playing') return;

      const key = e.key.toLowerCase();

      if (key === myNextKey) {
        // Correct key!
        myPosition += canvas.width * 0.05; // Move forward
        myScore += 10;
        myCombo++;
        myNextKey = getRandomKey();

        // Calculate progress (0 to 1)
        const startX = canvas.width * 0.1;
        const finishX = canvas.width * FINISH_LINE;
        myProgress = Math.min(1, (myPosition - startX) / (finishX - startX));

        // Send update to server
        socket.emit('player:update', {
          position: myPosition,
          progress: myProgress,
          score: myScore,
          combo: myCombo
        });

        // Check if finished
        if (myProgress >= 1) {
          finishRace();
        }
      } else if (KEYS.includes(key)) {
        // Wrong key
        myCombo = 0;
      }
    }

    function finishRace() {
      gameState = 'finished';
      const raceTime = ((Date.now() - raceStartTime) / 1000).toFixed(1);

      socket.emit('player:finished', {
        score: myScore,
        time: raceTime
      });

      document.removeEventListener('keydown', handleKeyPress);
    }

    function updateOpponentStates(players) {
      // Find opponent (not me)
      const opponent = players.find(p => p.id !== myPlayerId);
      if (opponent) {
        opponentData = opponent;
      }
    }

    function gameLoop() {
      if (gameState !== 'playing') {
        cancelAnimationFrame(animationFrame);
        return;
      }

      // Clear canvas
      ctx.fillStyle = '#020208';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw grid background
      drawGrid();

      // Draw finish line
      drawFinishLine();

      // Draw my runner
      drawRunner(myPosition, canvas.height * 0.4, '#00ffff', myPlayerName, myNextKey, true);

      // Draw opponent runner
      if (opponentData && currentRoom) {
        const opponentPlayer = currentRoom.players.find(p => p.id !== myPlayerId);
        if (opponentPlayer) {
          const startX = canvas.width * 0.1;
          const finishX = canvas.width * FINISH_LINE;
          const opponentPos = startX + (opponentData.progress * (finishX - startX));

          drawRunner(opponentPos, canvas.height * 0.6, '#ff00ff', opponentPlayer.name, null, false);
        }
      }

      // Draw HUD
      drawGameHUD();

      animationFrame = requestAnimationFrame(gameLoop);
    }

    function drawGrid() {
      ctx.strokeStyle = 'rgba(0, 255, 255, 0.1)';
      ctx.lineWidth = 1;
      const cellSize = 40;

      for (let x = 0; x < canvas.width; x += cellSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }

      for (let y = 0; y < canvas.height; y += cellSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }
    }

    function drawFinishLine() {
      const x = canvas.width * FINISH_LINE;

      ctx.save();
      ctx.strokeStyle = '#00ff88';
      ctx.lineWidth = 3;
      ctx.setLineDash([10, 5]);

      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, canvas.height);
      ctx.stroke();

      ctx.setLineDash([]);
      ctx.font = 'bold 20px Orbitron';
      ctx.fillStyle = '#00ff88';
      ctx.textAlign = 'center';
      ctx.shadowColor = '#00ff88';
      ctx.shadowBlur = 20;
      ctx.fillText('FINISH', x, 30);
      ctx.restore();
    }

    function drawRunner(x, y, color, name, nextKey, isMe) {
      // Draw runner shape (poly style)
      ctx.save();
      ctx.translate(x, y);

      // Glow effect
      ctx.shadowColor = color;
      ctx.shadowBlur = 30;

      // Body (triangle)
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.moveTo(0, -20);
      ctx.lineTo(15, 10);
      ctx.lineTo(-15, 10);
      ctx.closePath();
      ctx.fill();

      // Head
      ctx.beginPath();
      ctx.moveTo(0, -30);
      ctx.lineTo(8, -20);
      ctx.lineTo(-8, -20);
      ctx.closePath();
      ctx.fill();

      // Legs
      ctx.beginPath();
      ctx.moveTo(5, 10);
      ctx.lineTo(10, 30);
      ctx.lineTo(5, 30);
      ctx.closePath();
      ctx.fill();

      ctx.beginPath();
      ctx.moveTo(-5, 10);
      ctx.lineTo(-5, 30);
      ctx.lineTo(-10, 30);
      ctx.closePath();
      ctx.fill();

      ctx.restore();

      // Draw name above runner
      ctx.save();
      ctx.font = 'bold 14px Orbitron';
      ctx.fillStyle = color;
      ctx.textAlign = 'center';
      ctx.shadowColor = color;
      ctx.shadowBlur = 15;
      ctx.fillText(name, x, y - 50);
      ctx.restore();

      // Draw next key (only for player)
      if (isMe && nextKey) {
        ctx.save();
        ctx.font = 'bold 40px Orbitron';
        ctx.fillStyle = color;
        ctx.textAlign = 'center';
        ctx.shadowColor = color;
        ctx.shadowBlur = 30;
        const keyY = y - 80 - Math.sin(Date.now() * 0.005) * 5;
        ctx.fillText(nextKey.toUpperCase(), x, keyY);
        ctx.restore();
      }
    }

    function drawGameHUD() {
      ctx.save();
      ctx.font = 'bold 18px Orbitron';
      ctx.textAlign = 'left';

      // My stats (left side)
      ctx.fillStyle = '#00ffff';
      ctx.shadowColor = '#00ffff';
      ctx.shadowBlur = 15;
      ctx.fillText(`Score: ${myScore}`, 20, canvas.height - 60);
      ctx.fillText(`Combo: x${myCombo}`, 20, canvas.height - 30);

      // Opponent stats (right side)
      if (opponentData) {
        ctx.textAlign = 'right';
        ctx.fillStyle = '#ff00ff';
        ctx.shadowColor = '#ff00ff';
        ctx.fillText(`Score: ${opponentData.score || 0}`, canvas.width - 20, canvas.height - 60);
        ctx.fillText(`Combo: x${opponentData.combo || 0}`, canvas.width - 20, canvas.height - 30);
      }

      ctx.restore();
    }

    function showWinner(winner) {
      gameState = 'finished';
      cancelAnimationFrame(animationFrame);
      document.removeEventListener('keydown', handleKeyPress);

      // Draw winner overlay
      ctx.save();
      ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.font = 'bold 60px Orbitron';
      ctx.textAlign = 'center';
      ctx.fillStyle = winner.id === myPlayerId ? '#00ff88' : '#ff00ff';
      ctx.shadowColor = ctx.fillStyle;
      ctx.shadowBlur = 50;
      ctx.fillText(`${winner.name} WINS!`, canvas.width / 2, canvas.height / 2 - 50);

      ctx.font = 'bold 30px Orbitron';
      ctx.fillStyle = '#ffffff';
      ctx.shadowBlur = 20;
      ctx.fillText(`Time: ${winner.time}s | Score: ${winner.score}`, canvas.width / 2, canvas.height / 2 + 20);

      ctx.font = '20px Orbitron';
      ctx.fillStyle = '#00ffff';
      ctx.fillText('Returning to menu in 5 seconds...', canvas.width / 2, canvas.height / 2 + 80);
      ctx.restore();

      setTimeout(() => {
        gameState = 'menu';
        currentRoom = null;
        hideRoomUI();
        showMainMenu();
      }, 5000);
    }

    // Handle window resize
    window.addEventListener('resize', resizeCanvas);

    // =======================================
    // INITIALIZE
    // =======================================
    window.addEventListener('load', () => {
      initSocket();
    });
  </script>
</body>
</html>
