<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>POLY RACE - Type. Race. Win.</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
  <style>
    /* POLY RACE - Minimalistic Neon Game Theme */

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --cyan: #00ffff;
      --magenta: #ff00ff;
      --gold: #FFD700;
      --void: #000000;
      --dark: #0a0a0f;
    }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      overflow: hidden;
      background: radial-gradient(ellipse at center, #0a0a0f 0%, #000000 100%);
      font-family: 'Orbitron', sans-serif;
      color: #fff;
    }

    /* Fade-in animation */
    body {
      animation: fadeIn 0.8s ease-in;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }

    /* Loading overlay */
    #loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
      opacity: 1;
      pointer-events: none;
      z-index: 9999;
      transition: opacity 0.8s ease-in-out;
    }

    #loading-overlay.fade-out {
      opacity: 0;
    }

    /* Canvas container */
    #game-canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      display: block;
      background: transparent;
    }

    /* Prevent canvas from being affected by mobile keyboard */
    #game-canvas.keyboard-visible {
      height: 100vh;
    }

    /* Game HUD Overlay */
    #game-hud {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 100;
    }

    /* Title Card (for menu state) */
    #title-card {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 200;
    }

    .game-title {
      font-size: 6rem;
      font-weight: 900;
      letter-spacing: 15px;
      text-transform: uppercase;
      color: #fff;
      text-shadow:
        0 0 40px var(--cyan),
        0 0 80px var(--cyan),
        0 0 120px rgba(0, 255, 255, 0.3);
      margin-bottom: 1rem;
      line-height: 0.9;
    }

    .game-subtitle {
      font-size: 1.1rem;
      color: rgba(255, 255, 255, 0.5);
      letter-spacing: 6px;
      font-weight: 400;
      text-transform: uppercase;
      margin-bottom: 2rem;
    }

    .game-instruction {
      font-size: 0.9rem;
      color: rgba(0, 255, 255, 0.8);
      letter-spacing: 3px;
      font-weight: 600;
      text-shadow: 0 0 20px var(--cyan);
      animation: pulse 2s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% {
        opacity: 1;
      }
      50% {
        opacity: 0.6;
      }
    }

    /* Game Stats HUD */
    #stats-hud {
      position: absolute;
      top: 30px;
      width: 100%;
      display: flex;
      justify-content: center;
      gap: 60px;
      pointer-events: none;
    }

    .stat-display {
      text-align: center;
    }

    .stat-label {
      font-size: 0.75rem;
      color: rgba(255, 255, 255, 0.4);
      letter-spacing: 2px;
      font-weight: 500;
      margin-bottom: 5px;
    }

    .stat-value {
      font-size: 1.5rem;
      font-weight: 700;
      letter-spacing: 2px;
      text-shadow: 0 0 15px currentColor;
    }

    .stat-value.cyan {
      color: var(--cyan);
    }

    .stat-value.magenta {
      color: var(--magenta);
    }

    .stat-value.gold {
      color: var(--gold);
    }

    /* Key Indicators */
    #key-indicator {
      position: absolute;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 60px;
      pointer-events: none;
    }

    .player-keys {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
    }

    .player-label {
      font-size: 0.75rem;
      font-weight: 600;
      letter-spacing: 3px;
      text-shadow: 0 0 15px currentColor;
      opacity: 0.8;
    }

    .key-display {
      font-size: 2.5rem;
      font-weight: 800;
      padding: 20px 30px;
      border: 3px solid;
      border-radius: 8px;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(10px);
      min-width: 80px;
      text-align: center;
      box-shadow: 0 0 30px currentColor;
      transition: all 0.15s ease;
      letter-spacing: 2px;
    }

    .key-display.pressed {
      transform: scale(1.15);
      box-shadow: 0 0 50px currentColor;
      background: rgba(0, 0, 0, 0.95);
    }

    /* Win Screen */
    #win-screen {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 300;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s ease;
    }

    #win-screen.active {
      opacity: 1;
      pointer-events: all;
    }

    /* Idle Screen (same styling as win screen) */
    #idle-screen {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 300;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s ease;
    }

    #idle-screen.active {
      opacity: 1;
      pointer-events: all;
    }

    .win-title {
      font-size: 5rem;
      font-weight: 900;
      letter-spacing: 12px;
      margin-bottom: 1rem;
      text-shadow: 0 0 60px currentColor;
    }

    .win-stats {
      font-size: 1.2rem;
      color: rgba(255, 255, 255, 0.7);
      letter-spacing: 3px;
      margin: 0.5rem 0;
    }

    .win-restart {
      margin-top: 2rem;
      font-size: 0.9rem;
      color: var(--cyan);
      letter-spacing: 3px;
      text-shadow: 0 0 20px var(--cyan);
      animation: pulse 2s ease-in-out infinite;
    }

    /* Countdown */
    #countdown-display {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-family: 'Orbitron', sans-serif;
      font-size: 10rem;
      font-weight: 900;
      color: #00ffff;
      text-shadow:
        0 0 40px #00ffff,
        0 0 80px #00ffff,
        0 0 120px rgba(0, 255, 255, 0.5);
      z-index: 2500;
      opacity: 0;
      pointer-events: none;
      letter-spacing: 8px;
    }

    #countdown-display.active {
      animation: countdownPulse 1s ease-in-out;
    }

    @keyframes countdownPulse {
      0% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.3);
      }
      40% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1.3);
      }
      70% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1.1);
      }
      100% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(1.5);
      }
    }

    /* Mobile Touch Controls */
    #mobile-controls {
      display: none;
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      padding: 15px;
      background: linear-gradient(to top, rgba(0,0,0,0.98) 0%, rgba(0,0,0,0.9) 80%, transparent 100%);
      z-index: 150;
      pointer-events: none;
    }

    #mobile-controls.active {
      display: flex;
      flex-direction: column;
      align-items: center;
      pointer-events: all;
    }

    .mobile-hint {
      font-size: 0.7rem;
      color: rgba(255, 255, 255, 0.5);
      letter-spacing: 2px;
      text-align: center;
      margin-bottom: 10px;
      text-transform: uppercase;
    }

    /* Home Row Keyboard (for letter modes) */
    .home-row-keyboard {
      display: flex;
      gap: 5px;
      justify-content: center;
      flex-wrap: wrap;
      max-width: 100%;
      padding: 0 5px;
    }

    .key-button {
      padding: 14px 10px;
      font-family: 'Orbitron', sans-serif;
      font-size: 1.2rem;
      font-weight: 800;
      letter-spacing: 1px;
      color: rgba(255, 255, 255, 0.6);
      background: rgba(0, 0, 0, 0.8);
      border: 2px solid rgba(255, 255, 255, 0.2);
      border-radius: 6px;
      cursor: pointer;
      user-select: none;
      -webkit-user-select: none;
      -webkit-tap-highlight-color: transparent;
      transition: all 0.15s ease;
      min-width: 42px;
      text-align: center;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    .key-button.active {
      color: var(--cyan);
      border-color: var(--cyan);
      background: rgba(0, 255, 255, 0.1);
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.4);
      text-shadow: 0 0 10px var(--cyan);
    }

    .key-button:active {
      transform: scale(0.95);
      box-shadow: 0 0 30px var(--cyan);
    }

    .key-button.disabled {
      opacity: 0.3;
      pointer-events: none;
    }

    /* Full QWERTY Keyboard (for word/story modes) */
    .full-keyboard {
      display: flex;
      flex-direction: column;
      gap: 6px;
      width: 100%;
      max-width: 600px;
      padding: 0 5px;
    }

    .keyboard-row {
      display: flex;
      gap: 4px;
      justify-content: center;
    }

    .full-keyboard .key-button {
      padding: 14px 8px;
      font-size: 1.1rem;
      min-width: 40px;
      flex: 1;
      max-width: 50px;
    }

    .full-keyboard .key-button.space {
      flex: 3;
      max-width: none;
      font-size: 0.8rem;
    }

    /* Viewport adjustments when keyboard is visible */
    #game-canvas.keyboard-visible {
      height: calc(100vh - 280px) !important;
    }

    @media (max-width: 480px) {
      .key-button {
        padding: 15px 10px;
        font-size: 1.2rem;
        min-width: 42px;
      }

      .full-keyboard .key-button {
        padding: 12px 6px;
        font-size: 1rem;
        min-width: 32px;
        max-width: 42px;
      }

      #game-canvas.keyboard-visible {
        height: calc(100vh - 250px) !important;
      }
    }

    @media (max-width: 380px) {
      .key-button {
        padding: 12px 8px;
        font-size: 1rem;
        min-width: 38px;
        gap: 6px;
      }

      .full-keyboard .key-button {
        padding: 10px 4px;
        font-size: 0.9rem;
        min-width: 28px;
        max-width: 38px;
      }
    }

    /* Responsive - Mobile First */
    @media (max-width: 1024px) {
      #back-btn {
        top: 15px;
        left: 15px;
        width: 44px;
        height: 44px;
      }

      #back-btn svg {
        width: 18px;
        height: 18px;
      }

      .game-title {
        font-size: 4rem;
        letter-spacing: 10px;
      }

      .game-subtitle {
        font-size: 0.95rem;
      }

      .stat-value {
        font-size: 1.3rem;
      }

      .stat-label {
        font-size: 0.7rem;
      }
    }

    @media (max-width: 768px) {
      .game-title {
        font-size: 3rem;
        letter-spacing: 8px;
      }

      .game-subtitle {
        font-size: 0.85rem;
        letter-spacing: 4px;
      }

      .game-instruction {
        font-size: 0.8rem;
        letter-spacing: 2px;
      }

      #stats-hud {
        top: 15px;
        gap: 30px;
        flex-wrap: wrap;
        justify-content: center;
      }

      .stat-value {
        font-size: 1.1rem;
      }

      .stat-label {
        font-size: 0.65rem;
      }

      #key-indicator {
        gap: 20px;
        bottom: 240px;
        flex-wrap: wrap;
        justify-content: center;
      }

      #game-canvas.keyboard-visible ~ #game-hud #key-indicator {
        bottom: 260px;
      }

      .key-display {
        font-size: 1.5rem;
        padding: 12px 18px;
        min-width: 60px;
      }

      .player-label {
        font-size: 0.65rem;
        letter-spacing: 2px;
      }

      .win-title {
        font-size: 3rem;
        letter-spacing: 8px;
      }

      .win-stats {
        font-size: 1rem;
      }

      .win-restart {
        font-size: 0.8rem;
      }

      #countdown-display {
        font-size: 6rem;
      }
    }

    @media (max-width: 480px) {
      .game-title {
        font-size: 2.5rem;
        letter-spacing: 6px;
      }

      .game-subtitle {
        font-size: 0.75rem;
        letter-spacing: 3px;
      }

      .game-instruction {
        font-size: 0.7rem;
      }

      #stats-hud {
        gap: 15px;
      }

      .stat-value {
        font-size: 1rem;
      }

      .stat-label {
        font-size: 0.6rem;
      }

      #key-indicator {
        gap: 15px;
        bottom: 220px;
      }

      #game-canvas.keyboard-visible ~ #game-hud #key-indicator {
        bottom: 240px;
      }

      .key-display {
        font-size: 1.3rem;
        padding: 10px 15px;
        min-width: 50px;
      }

      .player-label {
        font-size: 0.6rem;
      }

      .win-title {
        font-size: 2.5rem;
        letter-spacing: 6px;
      }

      .win-stats {
        font-size: 0.9rem;
      }

      .win-restart {
        font-size: 0.7rem;
      }

      #countdown-display {
        font-size: 5rem;
      }

      .touch-button {
        padding: 20px 40px;
        font-size: 1.5rem;
        min-width: 180px;
      }

      #back-btn {
        top: 12px;
        left: 12px;
        width: 40px;
        height: 40px;
      }

      #back-btn svg {
        width: 16px;
        height: 16px;
      }
    }

    /* Landscape mode adjustments */
    @media (max-width: 900px) and (orientation: landscape) {
      .game-title {
        font-size: 2rem;
        letter-spacing: 6px;
      }

      .game-subtitle {
        font-size: 0.7rem;
        margin-bottom: 1.5rem;
      }

      #stats-hud {
        top: 10px;
        gap: 20px;
      }

      #key-indicator {
        bottom: 15px;
        gap: 15px;
      }

      .touch-button {
        bottom: 15px;
        padding: 15px 35px;
        font-size: 1.3rem;
      }
    }

    /* Custom Scrollbar */
    ::-webkit-scrollbar {
      width: 10px;
      height: 10px;
    }

    ::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.3);
      border-radius: 5px;
    }

    ::-webkit-scrollbar-thumb {
      background: linear-gradient(180deg, var(--cyan), var(--magenta));
      border-radius: 5px;
      box-shadow: 0 0 10px var(--cyan);
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--cyan);
      box-shadow: 0 0 20px var(--cyan);
    }

    /* Firefox scrollbar */
    * {
      scrollbar-width: thin;
      scrollbar-color: var(--cyan) rgba(0, 0, 0, 0.3);
    }

    /* Online Waiting Room */
    #online-waiting-room {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.95);
      z-index: 5000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }

    #online-waiting-room.active {
      opacity: 1;
      pointer-events: all;
    }

    .waiting-room-content {
      background: rgba(0, 0, 0, 0.85);
      border: 2px solid var(--cyan);
      border-radius: 15px;
      padding: 40px 30px;
      box-shadow: 0 0 40px rgba(0, 255, 255, 0.3), inset 0 0 30px rgba(0, 255, 255, 0.05);
    }

    .waiting-title {
      font-size: 2.5rem;
      font-weight: 900;
      letter-spacing: 5px;
      margin: 0 0 30px 0;
      text-transform: uppercase;
      color: #ffffff;
      text-shadow: 0 0 20px var(--cyan);
    }

    .invite-section {
      margin: 30px 0;
    }

    .invite-label {
      font-size: 0.9rem;
      color: rgba(255, 255, 255, 0.6);
      margin-bottom: 10px;
      letter-spacing: 2px;
      font-weight: 600;
    }

    .invite-link-container {
      display: flex;
      gap: 10px;
      align-items: center;
    }

    .invite-link-input {
      flex: 1;
      background: rgba(0, 0, 0, 0.6);
      border: 2px solid rgba(0, 255, 255, 0.3);
      border-radius: 8px;
      padding: 12px 15px;
      color: var(--cyan);
      font-family: 'Orbitron', monospace;
      font-size: 0.85rem;
      outline: none;
      transition: all 0.3s ease;
    }

    .invite-link-input:focus {
      border-color: var(--cyan);
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
    }

    .copy-link-btn {
      background: linear-gradient(135deg, rgba(0, 255, 255, 0.2), rgba(255, 0, 255, 0.2));
      border: 2px solid var(--cyan);
      border-radius: 8px;
      padding: 12px 20px;
      color: var(--cyan);
      font-family: 'Orbitron', monospace;
      font-size: 0.85rem;
      font-weight: 700;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .copy-link-btn:hover {
      background: var(--cyan);
      color: #000;
      box-shadow: 0 0 20px var(--cyan);
      transform: translateY(-2px);
    }

    .copy-link-btn:active {
      transform: translateY(0);
    }

    /* Game Mode Selector */
    .game-mode-section {
      margin: 30px 0;
    }

    .mode-selector {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
    }

    .mode-btn {
      background: rgba(0, 0, 0, 0.6);
      border: 2px solid rgba(0, 255, 255, 0.3);
      border-radius: 8px;
      padding: 15px 10px;
      color: rgba(255, 255, 255, 0.7);
      font-family: 'Orbitron', monospace;
      font-size: 0.75rem;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .mode-btn:hover {
      border-color: var(--cyan);
      background: rgba(0, 255, 255, 0.1);
      color: var(--cyan);
      transform: translateY(-2px);
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
    }

    .mode-btn.active {
      border-color: var(--cyan);
      background: rgba(0, 255, 255, 0.15);
      color: var(--cyan);
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
    }

    .mode-icon {
      font-size: 1.5rem;
      font-weight: 900;
    }

    .mode-name {
      font-size: 0.7rem;
      white-space: nowrap;
    }

    @media (max-width: 768px) {
      .mode-selector {
        grid-template-columns: repeat(2, 1fr);
        gap: 8px;
      }

      .mode-btn {
        padding: 12px 8px;
      }

      .mode-name {
        font-size: 0.65rem;
      }
    }

    .players-ready-status {
      display: flex;
      justify-content: space-around;
      align-items: center;
      margin: 40px 0;
      gap: 20px;
    }

    .player-status {
      flex: 1;
      background: rgba(0, 0, 0, 0.5);
      border: 2px solid rgba(0, 255, 255, 0.2);
      border-radius: 12px;
      padding: 20px;
      transition: all 0.3s ease;
    }

    .player-status.ready {
      border-color: #00ff88;
      box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
    }

    .player-status-icon {
      font-size: 3rem;
      margin-bottom: 10px;
      filter: grayscale(1);
      opacity: 0.5;
      transition: all 0.3s ease;
    }

    .player-status.ready .player-status-icon {
      filter: grayscale(0);
      opacity: 1;
      animation: pulse 2s ease-in-out infinite;
    }

    .player-status-name {
      font-size: 1rem;
      color: rgba(255, 255, 255, 0.8);
      margin-bottom: 10px;
      font-weight: 600;
    }

    .player-status-badge {
      display: inline-block;
      padding: 6px 15px;
      border-radius: 20px;
      font-size: 0.75rem;
      font-weight: 700;
      letter-spacing: 1px;
      text-transform: uppercase;
    }

    .player-status-badge.empty {
      background: rgba(255, 255, 255, 0.1);
      color: rgba(255, 255, 255, 0.3);
    }

    .player-status-badge.waiting {
      background: rgba(255, 165, 0, 0.2);
      color: #ffaa00;
      border: 1px solid #ffaa00;
      animation: pulse-badge 1.5s ease-in-out infinite;
    }

    .player-status-badge.ready {
      background: rgba(0, 255, 136, 0.2);
      color: #00ff88;
      border: 1px solid #00ff88;
    }

    @keyframes pulse-badge {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .vs-divider {
      font-size: 1.5rem;
      font-weight: 900;
      color: var(--magenta);
      text-shadow: 0 0 15px var(--magenta);
      letter-spacing: 3px;
    }

    .im-ready-btn {
      background: linear-gradient(135deg, rgba(0, 255, 255, 0.3), rgba(255, 0, 255, 0.3));
      border: 3px solid var(--cyan);
      border-radius: 12px;
      padding: 18px 60px;
      color: var(--cyan);
      font-family: 'Orbitron', monospace;
      font-size: 1.3rem;
      font-weight: 900;
      letter-spacing: 3px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      position: relative;
      overflow: hidden;
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.2);
    }

    .im-ready-btn::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      background: var(--cyan);
      border-radius: 50%;
      transform: translate(-50%, -50%);
      transition: width 0.5s ease, height 0.5s ease;
      z-index: 0;
    }

    .im-ready-btn:hover:not(:disabled)::before {
      width: 300%;
      height: 300%;
    }

    .im-ready-btn:hover:not(:disabled) {
      color: #000;
      box-shadow: 0 0 50px var(--cyan);
      transform: translateY(-3px);
    }

    .im-ready-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
      border-color: rgba(255, 255, 255, 0.2);
      color: rgba(255, 255, 255, 0.3);
    }

    .btn-text {
      position: relative;
      z-index: 1;
    }

    .ready-hint {
      margin-top: 15px;
      font-size: 0.9rem;
      color: rgba(255, 255, 255, 0.5);
      font-style: italic;
    }

    @media (max-width: 768px) {
      .waiting-title {
        font-size: 1.8rem;
        letter-spacing: 3px;
      }

      .waiting-room-content {
        padding: 30px 20px;
      }

      .players-ready-status {
        flex-direction: column;
        gap: 15px;
      }

      .vs-divider {
        transform: rotate(90deg);
        margin: 10px 0;
      }

      .im-ready-btn {
        padding: 15px 40px;
        font-size: 1.1rem;
      }
    }

    /* Touch-friendly buttons */
    @media (hover: none) and (pointer: coarse) {
      #back-btn {
        cursor: pointer;
        -webkit-tap-highlight-color: transparent;
      }

      #back-btn:active {
        transform: scale(0.95);
      }

      /* Ensure 44px minimum touch target on all interactive elements */
      .home-row-keyboard button, .full-keyboard button, .im-ready-btn {
        min-height: 44px;
        -webkit-tap-highlight-color: transparent;
      }
    }
  </style>
</head>
<body>
  <div id="loading-overlay"></div>

  <!-- Unified Back Button - Icon Focused -->
  <a href="modes.html" id="back-btn">
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
      <path d="M19 12H5M12 19l-7-7 7-7"/>
    </svg>
  </a>
  <style>
    #back-btn {
      position: fixed;
      top: 20px;
      left: 20px;
      width: 48px;
      height: 48px;
      padding: 0;
      font-family: 'Orbitron', sans-serif;
      background: rgba(0, 0, 0, 0.6);
      border: 1.5px solid rgba(0, 255, 255, 0.3);
      border-radius: 50%;
      text-decoration: none;
      z-index: 1000;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      backdrop-filter: blur(10px);
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    #back-btn:hover {
      background: rgba(0, 255, 255, 0.1);
      border-color: #00ffff;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.4), 0 4px 16px rgba(0, 0, 0, 0.4);
      transform: scale(1.08);
    }

    #back-btn:active {
      transform: scale(0.95);
    }

    #back-btn svg {
      width: 20px;
      height: 20px;
      stroke: #00ffff;
      transition: all 0.3s ease;
      filter: drop-shadow(0 0 4px rgba(0, 255, 255, 0.5));
    }

    #back-btn:hover svg {
      stroke: #fff;
      filter: drop-shadow(0 0 8px rgba(0, 255, 255, 0.8));
      transform: translateX(-2px);
    }
  </style>

  <canvas id="game-canvas"></canvas>

  <div id="game-hud">
    <!-- Title Card (shown in menu state - NOT for online mode) -->
    <div id="title-card" style="display: none;">
      <h1 class="game-title">POLY RACE</h1>
      <p class="game-subtitle">Type. Race. Win.</p>
      <p class="game-instruction" id="start-instruction">PRESS SPACE TO START</p>
    </div>

    <!-- Online Waiting Room (shown in online mode before race starts) -->
    <div id="online-waiting-room">
      <div class="waiting-room-content">
        <h1 class="waiting-title">
          <span style="color: #00ffff;">MULTIPLAYER</span> LOBBY
        </h1>

        <!-- Invite Link Section -->
        <div class="invite-section">
          <p class="invite-label">INVITE PLAYER</p>
          <div class="invite-link-container">
            <input type="text" id="game-invite-link" class="invite-link-input" readonly />
            <button id="copy-game-link-btn" class="copy-link-btn">
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
              </svg>
              COPY
            </button>
          </div>
        </div>

        <!-- Game Mode Selector -->
        <div class="game-mode-section">
          <p class="invite-label">GAME MODE</p>
          <div class="mode-selector">
            <button class="mode-btn active" data-mode="letters">
              <span class="mode-icon">A</span>
              <span class="mode-name">SINGLE LETTER</span>
            </button>
            <button class="mode-btn" data-mode="double">
              <span class="mode-icon">AB</span>
              <span class="mode-name">DOUBLE LETTER</span>
            </button>
            <button class="mode-btn" data-mode="words">
              <span class="mode-icon">üìù</span>
              <span class="mode-name">WORDS</span>
            </button>
            <button class="mode-btn" data-mode="story">
              <span class="mode-icon">üìñ</span>
              <span class="mode-name">STORY</span>
            </button>
          </div>
        </div>

        <!-- Players Ready Status -->
        <div class="players-ready-status">
          <div class="player-status" id="player1-status">
            <div class="player-status-icon">üë§</div>
            <div class="player-status-name" id="player1-name">Player 1</div>
            <div class="player-status-badge waiting" id="player1-badge">WAITING...</div>
          </div>
          <div class="vs-divider">VS</div>
          <div class="player-status" id="player2-status">
            <div class="player-status-icon">üë§</div>
            <div class="player-status-name" id="player2-name">Waiting for player...</div>
            <div class="player-status-badge empty" id="player2-badge">EMPTY</div>
          </div>
        </div>

        <!-- Ready Button -->
        <button id="im-ready-btn" class="im-ready-btn" disabled>
          <span class="btn-text">I'M READY</span>
        </button>
        <p class="ready-hint" id="ready-hint">Waiting for opponent to join...</p>
      </div>
    </div>

    <!-- Stats HUD (shown during gameplay) -->
    <div id="stats-hud" style="display: none;">
      <div class="stat-display">
        <div class="stat-label">TIME</div>
        <div class="stat-value cyan" id="time-display">0.0s</div>
      </div>
    </div>

    <!-- Countdown Display -->
    <div id="countdown-display" style="display: none;"></div>

    <!-- Key Indicators (shown during gameplay) -->
    <div id="key-indicator" style="display: none;"></div>

    <!-- Win Screen -->
    <div id="win-screen">
      <h2 class="win-title" id="win-title">PLAYER 1 WINS!</h2>
      <p class="win-stats" id="win-time">Time: 0.0s</p>
      <p class="win-stats" id="win-score">Score: 0</p>
      <p class="win-stats" id="win-combo">Max Combo: 0</p>
      <p class="win-restart" id="win-restart-text">PRESS SPACE TO RESTART</p>
    </div>

    <!-- Idle Screen -->
    <div id="idle-screen">
      <h2 class="win-title" style="color: #ffaa00;">RACE PAUSED</h2>
      <p class="win-stats" style="font-size: 1.2rem; margin: 20px 0;">No typing detected for 15 seconds</p>
      <p class="win-stats" id="idle-stats">Score: 0 | Progress: 0%</p>
      <p class="win-restart">PRESS SPACE TO RETRY</p>
    </div>
  </div>

  <!-- Mobile Touch Controls -->
  <div id="mobile-controls">
    <div class="mobile-hint" id="mobile-hint">TAP SCREEN TO START</div>

    <!-- Home Row Keyboard (for single/double letter modes) -->
    <div class="home-row-keyboard" id="home-row-keyboard" style="display: none;">
      <!-- Keys will be dynamically generated -->
    </div>

    <!-- Full QWERTY Keyboard (for word/story modes) -->
    <div class="full-keyboard" id="full-keyboard" style="display: none;">
      <div class="keyboard-row">
        <button class="key-button" data-key="q">Q</button>
        <button class="key-button" data-key="w">W</button>
        <button class="key-button" data-key="e">E</button>
        <button class="key-button" data-key="r">R</button>
        <button class="key-button" data-key="t">T</button>
        <button class="key-button" data-key="y">Y</button>
        <button class="key-button" data-key="u">U</button>
        <button class="key-button" data-key="i">I</button>
        <button class="key-button" data-key="o">O</button>
        <button class="key-button" data-key="p">P</button>
      </div>
      <div class="keyboard-row">
        <button class="key-button" data-key="a">A</button>
        <button class="key-button" data-key="s">S</button>
        <button class="key-button" data-key="d">D</button>
        <button class="key-button" data-key="f">F</button>
        <button class="key-button" data-key="g">G</button>
        <button class="key-button" data-key="h">H</button>
        <button class="key-button" data-key="j">J</button>
        <button class="key-button" data-key="k">K</button>
        <button class="key-button" data-key="l">L</button>
      </div>
      <div class="keyboard-row">
        <button class="key-button" data-key="z">Z</button>
        <button class="key-button" data-key="x">X</button>
        <button class="key-button" data-key="c">C</button>
        <button class="key-button" data-key="v">V</button>
        <button class="key-button" data-key="b">B</button>
        <button class="key-button" data-key="n">N</button>
        <button class="key-button" data-key="m">M</button>
      </div>
      <div class="keyboard-row">
        <button class="key-button space" data-key=" ">SPACE</button>
      </div>
    </div>
  </div>

  <script>
// ============================================
// Mobile Detection & Touch Controls
// ============================================
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                 (window.innerWidth <= 768);
const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

let mobileControlsActive = isMobile || isTouchDevice;

console.log('[MOBILE] Detection:', { isMobile, isTouchDevice, mobileControlsActive });

// Setup mobile controls if needed
if (mobileControlsActive) {
  window.addEventListener('load', () => {
    const mobileControls = document.getElementById('mobile-controls');
    const homeRowKeyboard = document.getElementById('home-row-keyboard');
    const fullKeyboard = document.getElementById('full-keyboard');
    const gameCanvas = document.getElementById('game-canvas');
    const winRestartText = document.getElementById('win-restart-text');
    const startInstruction = document.getElementById('start-instruction');
    const mobileHint = document.getElementById('mobile-hint');

    if (winRestartText) {
      winRestartText.textContent = 'TAP ANYWHERE TO RESTART';
    }

    if (startInstruction) {
      startInstruction.textContent = 'TAP ANYWHERE TO START';
    }

    let currentGameType = 'letters';
    let homeRowKeys = [];
    let keyboardInitialized = false;

    const urlParams = new URLSearchParams(window.location.search);
    const gameType = urlParams.get('type') || 'letters';
    currentGameType = gameType;

    console.log('[MOBILE] Game type:', currentGameType);

    function generateHomeRowKeyboard() {
      if (!homeRowKeyboard) return;

      homeRowKeyboard.innerHTML = '';

      let keys;

      if (currentGameType === 'double') {
        keys = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];
        homeRowKeys = keys;
      } else {
        keys = ['A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L'];
        homeRowKeys = keys;
      }

      keys.forEach(key => {
        const btn = document.createElement('button');
        btn.className = 'key-button';
        btn.setAttribute('data-key', key.toLowerCase());
        btn.textContent = key;
        homeRowKeyboard.appendChild(btn);
      });

      console.log('[MOBILE] Home row keyboard generated for type:', currentGameType);
    }

    function setupKeyboard() {
      if (keyboardInitialized) return;

      if (currentGameType === 'letters' || currentGameType === 'double') {
        generateHomeRowKeyboard();
        homeRowKeyboard.style.display = 'flex';
        fullKeyboard.style.display = 'none';
        mobileHint.textContent = 'TAP THE KEYS TO TYPE';
      } else {
        homeRowKeyboard.style.display = 'none';
        fullKeyboard.style.display = 'flex';
        mobileHint.textContent = 'USE KEYBOARD TO TYPE';
      }

      keyboardInitialized = true;
      console.log('[MOBILE] Keyboard setup complete');
    }

    function handleKeyPress(key) {
      const scene = game?.current_scene;
      if (!scene || scene.STATE !== "running") return;

      const keyDownEvent = new KeyboardEvent('keydown', {
        key: key,
        code: 'Key' + key.toUpperCase(),
        bubbles: true
      });
      document.dispatchEvent(keyDownEvent);

      const btn = document.querySelector(`[data-key="${key}"]`);
      if (btn) {
        btn.classList.add('active');
        setTimeout(() => {
          btn.classList.remove('active');
        }, 150);
      }

      setTimeout(() => {
        const keyUpEvent = new KeyboardEvent('keyup', {
          key: key,
          code: 'Key' + key.toUpperCase(),
          bubbles: true
        });
        document.dispatchEvent(keyUpEvent);
      }, 100);
    }

    function updateKeyboardHighlight(scene) {
      if (!scene || !scene.players || !scene.players[0]) return;

      const player = scene.players[0];
      let nextKey = '';

      if (player.isWordMode) {
        nextKey = player.nextKey[player.wordProgress];
      } else {
        nextKey = player.nextKey;
      }

      document.querySelectorAll('.key-button').forEach(btn => {
        btn.classList.remove('active');
      });

      if (nextKey) {
        const btn = document.querySelector(`[data-key="${nextKey.toLowerCase()}"]`);
        if (btn) {
          btn.classList.add('active');
        }
      }
    }

    function setupKeyEventListeners() {
      document.querySelectorAll('.key-button').forEach(btn => {
        btn.addEventListener('touchstart', (e) => {
          e.preventDefault();
          const key = btn.getAttribute('data-key');
          handleKeyPress(key);
        });

        btn.addEventListener('touchend', (e) => {
          e.preventDefault();
        });
      });
    }

    function updateMobileControls(scene) {
      if (!scene || !mobileControls) return;

      if (scene.STATE === "running" && scene.players && scene.players[0]) {
        if (!keyboardInitialized) {
          setupKeyboard();
          setupKeyEventListeners();
        }

        mobileControls.classList.add('active');
        gameCanvas.classList.add('keyboard-visible');
        updateKeyboardHighlight(scene);
      } else {
        mobileControls.classList.remove('active');
        gameCanvas.classList.remove('keyboard-visible');
      }
    }

    setInterval(() => {
      const scene = game?.current_scene;
      if (scene) {
        updateMobileControls(scene);
      }
    }, 100);

    let canStartGame = false;

    setTimeout(() => {
      canStartGame = true;
      console.log('[MOBILE] Ready to start game');
    }, 1000);

    document.getElementById('game-canvas').addEventListener('touchstart', (e) => {
      const scene = game?.current_scene;
      if (!scene) return;

      if (scene.STATE === "menu" && canStartGame) {
        e.preventDefault();
        console.log('[MOBILE] Starting countdown via tap');
        scene.startCountdown();
        canStartGame = false;
      } else if (scene.STATE === "win" && scene.canRestart) {
        e.preventDefault();
        console.log('[MOBILE] Restarting game via tap');
        game.startScene("PolyRace");
        canStartGame = false;
        setTimeout(() => {
          canStartGame = true;
        }, 1000);
      } else if (scene.STATE === "idle" && scene.canRestart) {
        e.preventDefault();
        console.log('[MOBILE] Restarting race after idle timeout via tap');
        game.startScene("PolyRace");
        canStartGame = false;
        setTimeout(() => {
          canStartGame = true;
        }, 1000);
      }
    });

    console.log('[MOBILE] Controls initialized');
  });
}
  </script>

  <script>
// Fade in effect on page load
window.addEventListener('load', () => {
  const overlay = document.getElementById('loading-overlay');
  if (overlay) {
    setTimeout(() => {
      overlay.classList.add('fade-out');
      setTimeout(() => {
        overlay.remove();
      }, 800);
    }, 100);
  }
});

// ============================================
// Utility
// ============================================
const Util = {
  timeStamp() { return window.performance.now(); },
  random(min, max) { return min + Math.random() * (max - min); },
  map(a,b,c,d,e){ return (a-b)/(c-b)*(e-d)+d; },
  lerp(a,b,t){ return a + (b-a)*t; },
  linearTween(t,b,c,d){ return c*t/d + b; },
  easeInOutQuad(t,b,c,d){ t/=d/2; if(t<1)return c/2*t*t+b; t--; return -c/2*(t*(t-2)-1)+b; }
};

// ============================================
// Vector
// ============================================
class Vector {
  constructor(x=0,y=0){ this.x=x; this.y=y; }
  set(x,y){ this.x=x; this.y=y; }
  add(v){ this.x+=v.x; this.y+=v.y; }
  mult(s){ this.x*=s; this.y*=s; }
  copy(){ return new Vector(this.x,this.y); }
  mag(){ return Math.hypot(this.x,this.y); }
}

// ============================================
// Scene base
// ============================================
class Scene {
  constructor(name){ this.name=name; this.loop=true; this.init_once=false; }
  giveWorld(world){ this.world=world; this.ctx=world.ctx; }
  keyEvents(e){} init(){} render(){}
}

// ============================================
// Physics + Entity base
// ============================================
class Body {
  constructor(entity,x,y){
    this.world = entity.world;
    this.step = this.world.FPS.step;
    this.position = new Vector(x,y);
    this.velocity = new Vector(0,0);
    this.acceleration = new Vector(0,0);
    this.drag = 0.92; // Increased from 0.88 for faster movement
  }
  applyForce(v){ this.acceleration.add(v); }
  integrate(){
    this.velocity.add(this.acceleration);
    this.velocity.mult(this.drag);
    const v = this.velocity.copy(); v.mult(this.step);
    this.position.add(v);
    this.acceleration.set(0,0);
  }
}

class Entity {
  constructor(scene,x,y){
    this.scene=scene; this.world=scene.world; this.ctx=this.world.ctx;
    this.body=new Body(this,x,y);
  }
  update(){} draw(){} render(){ this.update(); this.draw(); }
}

// ============================================
// OPTIMIZED Particle System
// ============================================
class Particle {
  constructor(x, y, color, vx, vy) {
    this.x = x;
    this.y = y;
    this.color = color;
    this.vx = vx;
    this.vy = vy;
    this.life = 1;
    this.size = Util.random(2, 4); // REDUCED from 2-6
  }
  update() {
    this.x += this.vx;
    this.y += this.vy;
    this.vy += 0.2;
    this.life -= 0.03; // FASTER decay (was 0.02)
  }
  draw(ctx) {
    if (this.life <= 0) return;
    ctx.globalAlpha = this.life;
    ctx.fillStyle = this.color;
    // REMOVED shadow for massive performance gain
    ctx.fillRect(this.x, this.y, this.size, this.size);
  }
}

// ============================================
// Runner (player) with detailed poly style
// ============================================
class Runner extends Entity {
  constructor(scene,x,y,color,keySet,scale=1.5,playerNum=1){
    super(scene,x,y);
    this.color=color;
    this.keySet=keySet;
    this.scale=scale;
    this.playerNum=playerNum;
    this.nextKey=this.getNewKey();
    this.keyPressed=false;
    this.lastKey=null;
    this.startX=x;
    this.popAlpha=0;
    this.score=0;
    this.combo=0;
    this.maxCombo=0;
    this.wrongKeyPenalty=0;
    this.particles = [];
    this.lastKeyTime=0;
    this.keySpeed=0;
    this.progressPercent=0;
    this.animTime=0;

    this.wordProgress=0;
    // Check if this is word/story mode by checking if items are multi-character strings
    this.isWordMode = this.keySet.length > 0 && typeof this.keySet[0] === 'string' && this.keySet[0].length > 2;

    this.hasChampionStatus = false;
    this.hasFinished = false;

    this.speedBonus = 0;
    this.speedBonusAlpha = 0;
    this.speedBonusText = '';
    this.comboTimeout = 1500;
  }

  getNewKey(){
    let newKey;
    do {
      const randomIndex=Math.floor(Util.random(0,this.keySet.length));
      newKey = this.keySet[randomIndex];
    } while(newKey === this.lastKey && this.keySet.length > 1);
    return newKey;
  }

  checkKeyPress(){
    const keys=this.world.keys;
    const now = Date.now();

    if(this.isWordMode){
      const currentChar = this.nextKey[this.wordProgress];
      const checkChar = currentChar.toLowerCase(); // Convert to lowercase for key checking

      if(keys[checkChar] && !this.keyPressed){
        this.keyPressed=true;
        this.lastKey=checkChar;

        const timeSinceLastKey = now - this.lastKeyTime;
        this.keySpeed = timeSinceLastKey;
        this.lastKeyTime = now;

        let forceMultiplier = 1;
        let basePoints = 10;
        let speedBonus = 0;
        let speedText = '';

        if(this.lastKeyTime === 0 || timeSinceLastKey > 2000) {
          forceMultiplier = 1;
        } else if(timeSinceLastKey < 150) {
          forceMultiplier = 1.5;
          speedBonus = 25;
          speedText = 'BLAZING!';
        } else if(timeSinceLastKey < 250) {
          forceMultiplier = 1.3;
          speedBonus = 15;
          speedText = 'FAST!';
        } else if(timeSinceLastKey < 400) {
          forceMultiplier = 1.15;
          speedBonus = 8;
          speedText = 'GOOD';
        } else if(timeSinceLastKey < 600) {
          forceMultiplier = 1.05;
          speedBonus = 3;
          speedText = '';
        }

        this.body.applyForce(new Vector(85 * forceMultiplier, 0)); // Increased from 65 for faster racing
        this.popAlpha=1;

        const totalPoints = basePoints + speedBonus + (this.combo * 2);
        this.score += totalPoints;

        if(speedText) {
          this.speedBonusText = speedText;
          this.speedBonusAlpha = 1;
        }

        this.combo++;
        if(this.combo > this.maxCombo) this.maxCombo = this.combo;

        this.spawnParticles(Math.floor(12 + speedBonus * 0.5));
        this.playBeep(440 + this.combo * 50);

        // Reset idle timer on activity
        if(this.scene) this.scene.lastActivityTime = Date.now();

        this.wordProgress++;

        if(this.wordProgress >= this.nextKey.length){
          this.wordProgress = 0;
        }
      }

      if(!this.keyPressed && this.scene.STATE==="running"){
        // Check for wrong key press - check all printable characters
        const allKeys = 'abcdefghijklmnopqrstuvwxyz .,!?\'"';
        for(let char of allKeys){
          if(keys[char] && char !== checkChar){
            this.wrongKeyPenalty = 10;
            this.combo = 0;
            this.playBeep(200);
            break;
          }
        }
      }

      if(this.keyPressed && !keys[this.lastKey]){
        this.keyPressed=false;
        if(this.wordProgress === 0){
          this.nextKey=this.getNewKey();
        }
      }
    } else {
      if(keys[this.nextKey] && !this.keyPressed){
        this.keyPressed=true;
        this.lastKey=this.nextKey;

        const timeSinceLastKey = now - this.lastKeyTime;
        this.keySpeed = timeSinceLastKey;
        this.lastKeyTime = now;

        let forceMultiplier = 1;
        let basePoints = 10;
        let speedBonus = 0;
        let speedText = '';

        if(this.lastKeyTime === 0 || timeSinceLastKey > 2000) {
          forceMultiplier = 1;
        } else if(timeSinceLastKey < 150) {
          forceMultiplier = 1.5;
          speedBonus = 25;
          speedText = 'BLAZING!';
        } else if(timeSinceLastKey < 250) {
          forceMultiplier = 1.3;
          speedBonus = 15;
          speedText = 'FAST!';
        } else if(timeSinceLastKey < 400) {
          forceMultiplier = 1.15;
          speedBonus = 8;
          speedText = 'GOOD';
        } else if(timeSinceLastKey < 600) {
          forceMultiplier = 1.05;
          speedBonus = 3;
          speedText = '';
        }

        this.body.applyForce(new Vector(85 * forceMultiplier, 0)); // Increased from 65 for faster racing
        this.popAlpha=1;

        const totalPoints = basePoints + speedBonus + (this.combo * 2);
        this.score += totalPoints;

        if(speedText) {
          this.speedBonusText = speedText;
          this.speedBonusAlpha = 1;
        }

        this.combo++;
        if(this.combo > this.maxCombo) this.maxCombo = this.combo;

        this.spawnParticles(Math.floor(12 + speedBonus * 0.5));
        this.playBeep(440 + this.combo * 50);

        // Reset idle timer on activity
        if(this.scene) this.scene.lastActivityTime = Date.now();
      }

      if(!this.keyPressed && this.scene.STATE==="running"){
        for(let key of this.keySet){
          if(keys[key] && key !== this.nextKey){
            this.wrongKeyPenalty = 10;
            this.combo = 0;
            this.playBeep(200);
            break;
          }
        }
      }

      if(this.keyPressed && !keys[this.lastKey]){
        this.keyPressed=false;
        this.nextKey=this.getNewKey();
      }
    }
  }

  playBeep(freq) {
    if(!this.world.audioCtx) return;
    const osc = this.world.audioCtx.createOscillator();
    const gain = this.world.audioCtx.createGain();
    osc.connect(gain);
    gain.connect(this.world.audioCtx.destination);
    osc.frequency.value = freq;
    gain.gain.value = 0.1;
    osc.start();
    gain.gain.exponentialRampToValueAtTime(0.01, this.world.audioCtx.currentTime + 0.1);
    osc.stop(this.world.audioCtx.currentTime + 0.1);
  }

  // OPTIMIZED: Reduce particle count by 50%
  spawnParticles(count) {
    const maxParticles = 30; // Particle limit
    const actualCount = Math.min(count * 0.5, maxParticles); // Reduce by 50%
    
    for(let i = 0; i < actualCount; i++) {
      const angle = Util.random(0, Math.PI * 2);
      const speed = Util.random(2, 6); // Reduced from 2-8
      this.particles.push(new Particle(
        this.body.position.x,
        this.body.position.y,
        this.color,
        Math.cos(angle) * speed,
        Math.sin(angle) * speed - 3
      ));
    }
    
    // Cull old particles if too many
    if (this.particles.length > maxParticles) {
      this.particles = this.particles.slice(-maxParticles);
    }
  }

  checkWin(){
    const progress = this.body.position.x - this.startX;
    const target = this.scene.raceDistancePixels;
    this.progressPercent = Math.min(100, (progress / target) * 100);

    if(progress >= target && !this.hasFinished){
      this.hasFinished = true;

      this.scene.STATE="win";
      this.scene.winner=this.scene.players.indexOf(this);
      this.scene.winnerStats = {
        score: this.score,
        maxCombo: this.maxCombo
      };

      if(this.scene.selectedMode === "online" && this.playerNum === 1) {
        console.log("[MULTIPLAYER] Local player finished!");
        if(window.multiplayerSocket) {
          window.multiplayerSocket.emit("player:finished");
        }
      }
    }
  }

  update(){
    this.body.integrate();
    if(this.popAlpha>0) this.popAlpha-=0.05;
    if(this.wrongKeyPenalty>0) this.wrongKeyPenalty-=0.3;
    if(this.body.velocity.x > 0.5) this.animTime += 0.15;

    if(this.speedBonusAlpha > 0) this.speedBonusAlpha -= 0.02;

    if(this.scene.STATE === "running" && this.combo > 0) {
      const timeSinceLastKey = Date.now() - this.lastKeyTime;
      if(timeSinceLastKey > this.comboTimeout) {
        this.combo = 0;
        this.wrongKeyPenalty = 5;
      }
    }

    this.particles = this.particles.filter(p => p.life > 0);
    this.particles.forEach(p => p.update());
  }

  poly(points, fill, stroke = null, lineWidth = 0) {
    const ctx = this.ctx;
    ctx.beginPath();
    ctx.moveTo(points[0].x, points[0].y);
    for (let i = 1; i < points.length; i++) {
      ctx.lineTo(points[i].x, points[i].y);
    }
    ctx.closePath();
    ctx.fillStyle = fill;
    ctx.fill();
    if (stroke) {
      ctx.strokeStyle = stroke;
      ctx.lineWidth = lineWidth;
      ctx.stroke();
    }
  }

  drawDetailedRunner(x, y, phase) {
    const ctx = this.ctx;
    const isAirborne = phase > 0.36 && phase < 0.86;
    const airLift = isAirborne ? Math.sin((phase - 0.36) / 0.5 * Math.PI) * 8 : 0;

    const legSwing = Math.sin(phase * Math.PI * 2) * 35;
    const legOpp = Math.sin(phase * Math.PI * 2 + Math.PI) * 35;

    const armSwing = Math.sin(phase * Math.PI * 2 + Math.PI) * 40;
    const armOpp = Math.sin(phase * Math.PI * 2) * 40;

    const lean = 18;
    const bob = Math.sin(phase * Math.PI * 2) * 3;

    const S = this.scale;
    y = y + bob - airLift;

    const torsoW = 24 * S;
    const torsoH = 42 * S;
    const headW = 20 * S;
    const headH = 24 * S;

    const torsoTop = y - torsoH - 12;
    const torsoBot = y - 12;

    const main = this.color;
    const light = this.lightenColor(this.color, 30);
    const dark = this.darkenColor(this.color, 30);
    const shade = this.darkenColor(this.color, 50);

    if(this.hasChampionStatus){
      this.drawCape(ctx, x + lean, torsoTop + 8, phase, S);
    }

    this.drawLeg(ctx, x, torsoBot, legOpp - 10, -8, dark, shade, true, S);
    this.drawArm(ctx, x + lean, torsoTop + 14, armOpp - 35, -14, dark, shade, true, S);

    this.poly([
      {x: x - torsoW/2 + lean, y: torsoTop},
      {x: x + torsoW/2 + lean, y: torsoTop},
      {x: x + torsoW/2 - 2, y: torsoBot},
      {x: x - torsoW/2 - 2, y: torsoBot}
    ], main);

    this.poly([
      {x: x + torsoW/2 + lean, y: torsoTop},
      {x: x + torsoW/2 + lean + 10, y: torsoTop + 6},
      {x: x + torsoW/2 + 8, y: torsoBot + 6},
      {x: x + torsoW/2 - 2, y: torsoBot}
    ], dark);

    const headX = x + lean + 10;
    const headY = torsoTop - headH - 2;

    this.poly([
      {x: headX - headW/2, y: headY + 4},
      {x: headX + headW/2, y: headY},
      {x: headX + headW/2 + 2, y: headY + headH - 4},
      {x: headX, y: headY + headH},
      {x: headX - headW/2 - 2, y: headY + headH - 4}
    ], light);

    this.poly([
      {x: headX + headW/2, y: headY},
      {x: headX + headW/2 + 12, y: headY + 4},
      {x: headX + headW/2 + 10, y: headY + headH - 2},
      {x: headX + headW/2 + 2, y: headY + headH - 4}
    ], dark);

    this.poly([
      {x: headX - headW/2, y: headY + 4},
      {x: headX + headW/2, y: headY},
      {x: headX + headW/2 + 12, y: headY + 4},
      {x: headX, y: headY + 8}
    ], main);

    this.drawLeg(ctx, x, torsoBot, legSwing + 10, 8, main, dark, false, S);
    this.drawArm(ctx, x + lean, torsoTop + 14, armSwing + 20, -10, main, dark, false, S);

    if(this.hasChampionStatus){
      this.drawCrown(ctx, headX, headY - 12, S);
    }
  }

  drawCape(ctx, x, y, phase, S) {
    const capeFlow = Math.sin(phase * Math.PI * 2) * 15 - 20;
    const capeColor = "#ffaa00";
    const capeShadow = this.darkenColor(capeColor, 40);

    ctx.globalAlpha = 0.7;

    this.poly([
      {x: x - 8, y: y},
      {x: x + 8, y: y},
      {x: x + 12 + capeFlow, y: y + 50 * S},
      {x: x - 12 + capeFlow, y: y + 50 * S}
    ], capeColor);

    this.poly([
      {x: x + 8, y: y},
      {x: x + 8 + capeFlow/2, y: y + 25 * S},
      {x: x + 12 + capeFlow, y: y + 50 * S},
      {x: x, y: y + 45 * S}
    ], capeShadow);

    ctx.globalAlpha = 1.0;
  }

  drawCrown(ctx, x, y, S) {
    const crownColor = "#ffdd00";
    const crownShadow = this.darkenColor(crownColor, 30);

    ctx.shadowColor = crownColor;
    ctx.shadowBlur = 15;

    this.poly([
      {x: x - 12 * S, y: y + 10},
      {x: x + 12 * S, y: y + 10},
      {x: x + 10 * S, y: y},
      {x: x - 10 * S, y: y}
    ], crownColor);

    this.poly([
      {x: x - 10 * S, y: y},
      {x: x - 6 * S, y: y - 8},
      {x: x - 2 * S, y: y + 2}
    ], crownColor);

    this.poly([
      {x: x - 2 * S, y: y + 2},
      {x: x, y: y - 12},
      {x: x + 2 * S, y: y + 2}
    ], crownShadow);

    this.poly([
      {x: x + 2 * S, y: y + 2},
      {x: x + 6 * S, y: y - 8},
      {x: x + 10 * S, y: y}
    ], crownColor);

    ctx.shadowBlur = 0;
  }

  // OPTIMIZED: Reduced joint detail from 6 to 4 points
  drawLeg(ctx, x, hipY, angle, offsetX, color1, color2, isBack, S) {
    const a = angle * Math.PI / 180;
    const thighLen = 30 * S;
    const shinLen = 30 * S;

    const hipX = x + offsetX;
    const kneeX = hipX + Math.sin(a) * thighLen;
    const kneeY = hipY + Math.cos(a) * thighLen;

    const shinA = a - 0.6;
    const ankleX = kneeX + Math.sin(shinA) * shinLen;
    const ankleY = kneeY + Math.cos(shinA) * shinLen;

    const legW = 11;
    const kneeW = 13;

    if (isBack) ctx.globalAlpha = 0.4;

    const thighAngle = Math.atan2(kneeX - hipX, kneeY - hipY);
    const thighPerpX = Math.cos(thighAngle) * legW/2;
    const thighPerpY = -Math.sin(thighAngle) * legW/2;

    this.poly([
      {x: hipX - thighPerpX, y: hipY - thighPerpY},
      {x: hipX + thighPerpX, y: hipY + thighPerpY},
      {x: kneeX + thighPerpX, y: kneeY + thighPerpY},
      {x: kneeX - thighPerpX, y: kneeY - thighPerpY}
    ], color1);

    // OPTIMIZED: Reduced from 6 to 4 points
    const kneePts = [];
    for (let i = 0; i < 4; i++) {
      const ang = (i / 4) * Math.PI * 2;
      kneePts.push({
        x: kneeX + Math.cos(ang) * kneeW/2,
        y: kneeY + Math.sin(ang) * kneeW/2
      });
    }
    this.poly(kneePts, this.lightenColor(this.color, 20));

    const shinAngle = Math.atan2(ankleX - kneeX, ankleY - kneeY);
    const shinPerpX = Math.cos(shinAngle) * (legW-2)/2;
    const shinPerpY = -Math.sin(shinAngle) * (legW-2)/2;

    this.poly([
      {x: kneeX - shinPerpX, y: kneeY - shinPerpY},
      {x: kneeX + shinPerpX, y: kneeY + shinPerpY},
      {x: ankleX + shinPerpX, y: ankleY + shinPerpY},
      {x: ankleX - shinPerpX, y: ankleY - shinPerpY}
    ], color2);

    this.poly([
      {x: ankleX - 8, y: ankleY},
      {x: ankleX + 18, y: ankleY},
      {x: ankleX + 20, y: ankleY + 10},
      {x: ankleX - 6, y: ankleY + 10}
    ], this.darkenColor(this.color, 60));

    if (isBack) ctx.globalAlpha = 1.0;
  }

  // OPTIMIZED: Reduced joint detail from 6 to 4 points
  drawArm(ctx, shoulderX, shoulderY, angle, offsetX, color1, color2, isBack, S) {
    const a = angle * Math.PI / 180;
    const upperLen = 24 * S;
    const lowerLen = 22 * S;

    shoulderX = shoulderX + offsetX;
    const elbowX = shoulderX + Math.sin(a) * upperLen;
    const elbowY = shoulderY + Math.cos(a) * upperLen;

    const foreA = a + 0.8;
    const handX = elbowX + Math.sin(foreA) * lowerLen;
    const handY = elbowY + Math.cos(foreA) * lowerLen;

    const armW = 9;
    const elbowW = 11;

    if (isBack) ctx.globalAlpha = 0.4;

    const upperAngle = Math.atan2(elbowX - shoulderX, elbowY - shoulderY);
    const upperPerpX = Math.cos(upperAngle) * armW/2;
    const upperPerpY = -Math.sin(upperAngle) * armW/2;

    this.poly([
      {x: shoulderX - upperPerpX, y: shoulderY - upperPerpY},
      {x: shoulderX + upperPerpX, y: shoulderY + upperPerpY},
      {x: elbowX + upperPerpX, y: elbowY + upperPerpY},
      {x: elbowX - upperPerpX, y: elbowY - upperPerpY}
    ], color1);

    // OPTIMIZED: Reduced from 6 to 4 points
    const elbowPts = [];
    for (let i = 0; i < 4; i++) {
      const ang = (i / 4) * Math.PI * 2;
      elbowPts.push({
        x: elbowX + Math.cos(ang) * elbowW/2,
        y: elbowY + Math.sin(ang) * elbowW/2
      });
    }
    this.poly(elbowPts, this.lightenColor(this.color, 20));

    const foreAngle = Math.atan2(handX - elbowX, handY - elbowY);
    const forePerpX = Math.cos(foreAngle) * (armW-2)/2;
    const forePerpY = -Math.sin(foreAngle) * (armW-2)/2;

    this.poly([
      {x: elbowX - forePerpX, y: elbowY - forePerpY},
      {x: elbowX + forePerpX, y: elbowY + forePerpY},
      {x: handX + forePerpX, y: handY + forePerpY},
      {x: handX - forePerpX, y: handY - forePerpY}
    ], color2);

    this.poly([
      {x: handX - 7, y: handY},
      {x: handX + 7, y: handY},
      {x: handX + 9, y: handY + 7},
      {x: handX, y: handY + 11},
      {x: handX - 9, y: handY + 7}
    ], this.lightenColor(this.color, 10));

    if (isBack) ctx.globalAlpha = 1.0;
  }

  lightenColor(color, percent) {
    const num = parseInt(color.replace("#",""), 16);
    const amt = Math.round(2.55 * percent);
    const R = Math.min(255, (num >> 16) + amt);
    const G = Math.min(255, (num >> 8 & 0x00FF) + amt);
    const B = Math.min(255, (num & 0x0000FF) + amt);
    return "#" + (0x1000000 + R*0x10000 + G*0x100 + B).toString(16).slice(1);
  }

  darkenColor(color, percent) {
    const num = parseInt(color.replace("#",""), 16);
    const amt = Math.round(2.55 * percent);
    const R = Math.max(0, (num >> 16) - amt);
    const G = Math.max(0, (num >> 8 & 0x00FF) - amt);
    const B = Math.max(0, (num & 0x0000FF) - amt);
    return "#" + (0x1000000 + R*0x10000 + G*0x100 + B).toString(16).slice(1);
  }

  drawHUD(ctx){
    const scene = this.scene;
    if(scene.selectedMode === "online" && this.playerNum !== 1) {
      return;
    }

    ctx.save();
    const pos = this.body.position;

    const keyY=pos.y - 120 - Math.sin(Date.now()*0.005)*8;
    const shakeX = this.wrongKeyPenalty > 0 ? Math.sin(Date.now() * 0.5) * this.wrongKeyPenalty * 0.3 : 0;

    if(this.isWordMode){
      const fullText = this.nextKey;

      // For story mode (long sentences), show a sliding window of text
      let displayText = fullText;
      let displayProgress = this.wordProgress;

      if(fullText.length > 20) {
        // This is a long sentence (story mode) - show small window
        // Show 5 chars before and 15 chars after = ~20 chars total (2-3 words)
        let start = Math.max(0, this.wordProgress - 5);
        let end = Math.min(fullText.length, this.wordProgress + 15);

        // Adjust to word boundaries
        while(start > 0 && fullText[start - 1] !== ' ' && (this.wordProgress - start) < 10) start--;
        while(end < fullText.length && fullText[end] !== ' ' && (end - this.wordProgress) < 20) end++;

        displayText = fullText.substring(start, end);
        displayProgress = this.wordProgress - start;

        // Add ellipsis if text is truncated - but NOT at the very start
        if(start > 0 && this.wordProgress > 8) {
          displayText = '...' + displayText;
          displayProgress += 3;
        }
        if(end < fullText.length && this.wordProgress < fullText.length - 10) {
          displayText = displayText + '...';
        }

        // Use smaller font for story mode
        ctx.font="bold 36px 'Orbitron'";
      } else {
        // Regular word mode - larger font
        ctx.font="bold 48px 'Orbitron'";
      }

      ctx.textAlign="center";

      const word = displayText.toUpperCase();
      const completedPart = word.substring(0, displayProgress);
      const remainingPart = word.substring(displayProgress);

      const totalWidth = ctx.measureText(word).width;
      const completedWidth = ctx.measureText(completedPart).width;

      if(completedPart){
        ctx.fillStyle="rgba(0,255,136,0.7)";
        ctx.shadowColor="rgba(0,255,136,0.7)";
        ctx.shadowBlur=20;
        ctx.fillText(completedPart, pos.x + shakeX - totalWidth/2 + completedWidth/2, keyY);
      }

      if(remainingPart){
        ctx.fillStyle=this.wrongKeyPenalty > 0 ? "#ff0000" : this.color;
        ctx.shadowColor=this.wrongKeyPenalty > 0 ? "#ff0000" : this.color;
        ctx.shadowBlur=40;
        ctx.fillText(remainingPart, pos.x + shakeX + completedWidth - totalWidth/2 + ctx.measureText(remainingPart).width/2, keyY);
      }

      if(this.popAlpha>0){
        ctx.globalAlpha=this.popAlpha;
        // Use matching font size for pop effect
        ctx.font = fullText.length > 20 ? "bold 42px 'Orbitron'" : "bold 56px 'Orbitron'";
        ctx.fillStyle=this.color;
        ctx.fillText(word, pos.x, keyY);
      }
    } else {
      ctx.font="bold 52px 'Orbitron'";
      ctx.textAlign="center";
      ctx.fillStyle=this.wrongKeyPenalty > 0 ? "#ff0000" : this.color;
      ctx.shadowColor=this.wrongKeyPenalty > 0 ? "#ff0000" : this.color;
      ctx.shadowBlur=40;
      ctx.globalAlpha=0.9;
      ctx.fillText(this.nextKey.toUpperCase(), pos.x + shakeX, keyY);

      if(this.popAlpha>0){
        ctx.globalAlpha=this.popAlpha;
        ctx.font="bold 64px 'Orbitron'";
        ctx.fillText(this.nextKey.toUpperCase(), pos.x, keyY);
      }
    }

    if(this.combo > 2){
      ctx.globalAlpha=1;
      ctx.font="bold 24px 'Orbitron'";
      ctx.fillStyle=this.color;
      ctx.shadowBlur=30;
      ctx.fillText(`COMBO x${this.combo}`, pos.x, keyY - 55);
    }

    if(this.speedBonusAlpha > 0){
      ctx.globalAlpha=this.speedBonusAlpha;
      ctx.font="bold 20px 'Orbitron'";

      if(this.speedBonusText === 'BLAZING!'){
        ctx.fillStyle='#ff3366';
        ctx.shadowColor='#ff3366';
      } else if(this.speedBonusText === 'FAST!'){
        ctx.fillStyle='#ffaa00';
        ctx.shadowColor='#ffaa00';
      } else {
        ctx.fillStyle='#00ff88';
        ctx.shadowColor='#00ff88';
      }

      ctx.shadowBlur=25;
      const bonusY = this.combo > 2 ? keyY - 85 : keyY - 55;
      ctx.fillText(this.speedBonusText, pos.x, bonusY);
    }

    // Finish line warning when close (90-99%)
    if(this.progressPercent >= 90 && this.progressPercent < 100 && this.scene.STATE === "running"){
      const pulse = (Math.sin(Date.now() * 0.01) + 1) * 0.5; // 0 to 1
      ctx.globalAlpha = 0.7 + pulse * 0.3;
      ctx.font="bold 28px 'Orbitron'";
      ctx.fillStyle='#ffff00';
      ctx.shadowColor='#ffff00';
      ctx.shadowBlur=30;
      ctx.textAlign="center";
      ctx.fillText('FINISH LINE AHEAD!', pos.x, keyY - 120);
    }

    ctx.restore();
  }

  drawProgressBar(ctx){
    const barWidth = 220;
    const barHeight = 14;

    let x, y;

    if (window.mobileControlsActive) {
      x = this.world.W / 2 - barWidth / 2;
      y = 30;
    } else {
      x = this.body.position.x - barWidth / 2;
      y = this.body.position.y + 60;
    }

    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.6)";
    ctx.fillRect(x, y, barWidth, barHeight);

    ctx.fillStyle = this.color;
    ctx.shadowColor = this.color;
    ctx.shadowBlur = 20;
    ctx.fillRect(x, y, barWidth * (this.progressPercent/100), barHeight);

    ctx.strokeStyle = this.color;
    ctx.lineWidth = 2;
    ctx.strokeRect(x, y, barWidth, barHeight);

    ctx.font="bold 11px 'Orbitron'";
    ctx.fillStyle="#ffffff";
    ctx.shadowBlur=10;
    ctx.textAlign="center";

    const textX = window.mobileControlsActive ? this.world.W / 2 : this.body.position.x;
    ctx.fillText(`${Math.floor(this.progressPercent)}%`, textX, y + barHeight - 1);
    ctx.restore();
  }

  // OPTIMIZED: Reduced shadow blur from 30 to 10
  draw(){
    const ctx=this.world.ctx;
    const pos=this.body.position;

    // Particles (no shadow)
    ctx.save();
    this.particles.forEach(p => p.draw(ctx));
    ctx.restore();

    // Main character with REDUCED glow
    ctx.save();
    ctx.shadowColor=this.color;
    ctx.shadowBlur=10; // REDUCED from 30 for massive performance gain

    const phase = (this.animTime) % 1;
    this.drawDetailedRunner(pos.x, pos.y, phase);
    ctx.restore();

    if(this.scene.STATE==="running"){
      this.drawHUD(ctx);
      this.drawProgressBar(ctx);
    }
  }
}

// ============================================
// Scene: Poly Race Typing Duel
// ============================================
const PolyRaceScene = new Scene("PolyRace");

PolyRaceScene.WORD_POOL = [
  'speed', 'race', 'fast', 'type', 'win', 'quick', 'rush', 'zoom', 'dash', 'run',
  'jump', 'move', 'leap', 'fly', 'bolt', 'sprint', 'chase', 'pace', 'swift', 'rapid',
  'code', 'game', 'play', 'skill', 'power', 'boost', 'track', 'score', 'goal', 'star'
];

PolyRaceScene.DOUBLE_LETTERS = [
  'ab', 'cd', 'ef', 'gh', 'ij', 'kl', 'mn', 'op', 'qr', 'st',
  'uv', 'wx', 'yz', 'ac', 'bd', 'ce', 'df', 'eg', 'fh', 'gi',
  'hj', 'ik', 'jl', 'km', 'ln', 'mo', 'np', 'oq', 'pr', 'qs'
];

PolyRaceScene.STORY_POOL = [
  'The quick brown fox jumps over the lazy dog.',
  'Practice makes perfect in every skill you learn.',
  'Speed and accuracy are both important.',
  'Keep your eyes on the screen and type fast.',
  'Racing against time improves your typing.',
  'Every keystroke counts in this challenge.',
  'Focus on the letters and move your fingers.',
  'Compete with friends and improve together.',
  'The faster you type, the quicker you win.',
  'Master the keyboard one race at a time.'
];

PolyRaceScene.init=function(){
  this.ctx=this.world.ctx;
  this.players=[];

  this.STATE="menu";
  this.titleFloat=0;
  this.countSeq=["READY","SET","GO!"];
  this.countIndex=0;
  this.countStart=0;
  this.winner=null;
  this.winnerStats=null;
  this.canRestart=false;
  this.raceStartTime=0;
  this.raceTime=0;

  const urlParams = new URLSearchParams(window.location.search);
  const urlMode = urlParams.get('mode');
  const urlRaceType = urlParams.get('race');
  const urlTypingMode = urlParams.get('type');
  const urlRoomCode = urlParams.get('room');
  const urlPlayers = urlParams.get('players');

  this.selectedMode = urlMode || "practice";

  if (urlMode === "online") {
    const selectedMode = sessionStorage.getItem('selectedGameMode') || "letters";
    this.gameMode = selectedMode;
    console.log('[SCENE] Online mode: Using selected game mode:', selectedMode);
  } else {
    this.gameMode = urlTypingMode || "letters";
  }

  this.playerCount = parseInt(urlPlayers) || 2;

  // Race distance based on type
  if(urlRaceType === "marathon") {
    this.raceDistancePixels = 2400; // Long race
  } else if(urlRaceType === "sprint") {
    this.raceDistancePixels = 400; // Quick race
  } else {
    this.raceDistancePixels = 600; // Default: shorter for better UX (reduced from 800)
  }

  this.atmosphereOffset=0;
  this.cameraX=0;
  this.targetCameraX=0;
  this.cameraY=0; // Vertical camera offset for mobile keyboard
  this.gridOffset=0;

  // Frame counter for throttled updates
  this._keyIndicatorFrame = 0;

  // Idle detection
  this.lastActivityTime = Date.now();
  this.idleTimeout = 15000; // 15 seconds of no typing
  this.isIdle = false;

  this.initPlayers();
  this.updateUIState();

  console.log('[GAME] Ready to start. Press SPACE or TAP to begin.');
};

PolyRaceScene.initPlayers=function(){
  this.players=[];

  const startX = 200;
  const playerColors = ["#00ffff", "#ff00ff", "#00ff88", "#FFD700"];
  const playerKeySets = [
    ["a","s","d","f","g","h"],
    ["j","k","l","u","i","o"],
    ["q","w","e","r","t","y"],
    ["z","x","c","v","b","n"]
  ];

  const getYPosition = (index, totalPlayers) => {
    if (totalPlayers === 1) {
      return this.world.H * 0.65;
    } else if (totalPlayers === 2) {
      return index === 0 ? this.world.H * 0.58 : this.world.H * 0.72;
    } else {
      const spacing = 0.15;
      const startY = 0.45;
      return this.world.H * (startY + (index * spacing));
    }
  };

  for(let i = 0; i < this.playerCount; i++) {
    const color = playerColors[i];
    const yPos = getYPosition(i, this.playerCount);
    let keySet;

    if(this.gameMode === "letters") {
      keySet = playerKeySets[i];
    } else if(this.gameMode === "double") {
      keySet = this.DOUBLE_LETTERS;
    } else if(this.gameMode === "words") {
      keySet = this.WORD_POOL;
    } else if(this.gameMode === "story") {
      keySet = this.STORY_POOL;
    } else if(this.gameMode === "custom") {
      keySet = this.WORD_POOL;
    } else {
      keySet = playerKeySets[i];
    }

    const player = new Runner(this, startX, yPos, color, keySet, 1.6, i + 1);
    this.players.push(player);
  }
};

PolyRaceScene.updateUIState=function(){
  const titleCard = document.getElementById('title-card');
  const statsHud = document.getElementById('stats-hud');
  const keyIndicator = document.getElementById('key-indicator');
  const winScreen = document.getElementById('win-screen');
  const idleScreen = document.getElementById('idle-screen');

  if(this.STATE === "menu"){
    if(this.selectedMode !== "online") {
      titleCard.style.display = 'block';
    }
    statsHud.style.display = 'none';
    keyIndicator.style.display = 'none';
    winScreen.classList.remove('active');
    idleScreen.classList.remove('active');
  } else if(this.STATE === "countdown" || this.STATE === "running"){
    titleCard.style.display = 'none';
    statsHud.style.display = 'flex';
    keyIndicator.style.display = 'flex';
    winScreen.classList.remove('active');
    idleScreen.classList.remove('active');
  } else if(this.STATE === "win"){
    titleCard.style.display = 'none';
    statsHud.style.display = 'none';
    keyIndicator.style.display = 'none';
    winScreen.classList.add('active');
    idleScreen.classList.remove('active');
  } else if(this.STATE === "idle"){
    titleCard.style.display = 'none';
    statsHud.style.display = 'none';
    keyIndicator.style.display = 'none';
    winScreen.classList.remove('active');
    idleScreen.classList.add('active');
  }
};

// OPTIMIZED: Throttle key indicator updates to every 3 frames
PolyRaceScene.updateKeyIndicator=function(){
  if (!this._keyIndicatorFrame) this._keyIndicatorFrame = 0;
  this._keyIndicatorFrame++;
  if (this._keyIndicatorFrame % 3 !== 0) return; // Only update every 3 frames
  
  const indicator = document.getElementById('key-indicator');
  if(this.STATE === "running") {
    const playersToShow = this.selectedMode === "online" ? [this.players[0]] : this.players;

    indicator.innerHTML = playersToShow.map((p, i) => {
      if (!p) return '';

      const actualIndex = this.selectedMode === "online" ? 0 : i;
      let displayKey;
      let isPressed;

      if(p.isWordMode) {
        displayKey = p.nextKey[p.wordProgress].toUpperCase();
        isPressed = this.world.keys[p.nextKey[p.wordProgress].toLowerCase()];
      } else {
        displayKey = p.nextKey.toUpperCase();
        isPressed = this.world.keys[p.nextKey];
      }

      return `
        <div class="player-keys">
          <div class="player-label" style="color: ${p.color}">${this.selectedMode === "online" ? 'YOU' : 'PLAYER ' + (actualIndex+1)}</div>
          <div class="key-display ${isPressed ? 'pressed' : ''}" style="color: ${p.color}; border-color: ${p.color}">
            ${displayKey}
          </div>
        </div>
      `;
    }).join('');
  }
};

PolyRaceScene.keyEvents=function(e){
  if(e.key===" "){
    if(this.STATE==="menu"){ this.startCountdown(); }
    else if(this.STATE==="win" && this.canRestart){ this.world.startScene("PolyRace"); }
    else if(this.STATE==="idle" && this.canRestart){
      console.log('[IDLE] Restarting race after idle timeout');
      this.world.startScene("PolyRace");
    }
  }
  if(e.key==="Escape" && this.STATE==="running"){
    this.STATE="menu";
    this.init();
  }
};

PolyRaceScene.startCountdown=function(){
  this.STATE="countdown";
  this.countIndex=0;
  this.countStart=new Date();
  this.updateUIState();
};

PolyRaceScene.advanceCountdown=function(){
  this.countIndex++;
  if(this.countIndex>=this.countSeq.length){
    this.STATE="running";
    this.raceStartTime=Date.now();
    this.updateUIState();
  }
  else { this.countStart=new Date(); }
};

PolyRaceScene.updateCountdown=function(){
  if(new Date()-this.countStart>1000){ this.advanceCountdown(); }
};

PolyRaceScene.showCountdownText=function(text){
  const display = document.getElementById('countdown-display');
  display.textContent = text;
  display.style.display = 'block';
  display.classList.remove('active');

  void display.offsetWidth;

  display.classList.add('active');

  setTimeout(() => {
    display.style.display = 'none';
    display.classList.remove('active');
  }, 1000);
};

PolyRaceScene.updateCamera=function(){
  if(this.STATE==="running"){
    const leadPlayer = this.players.reduce((lead, p) =>
      p.body.position.x > lead.body.position.x ? p : lead
    );

    this.targetCameraX = leadPlayer.body.position.x - this.world.W * 0.3;
    this.targetCameraX = Math.max(0, this.targetCameraX);

    this.cameraX += (this.targetCameraX - this.cameraX) * 0.08;

    // Vertical camera offset for mobile keyboard
    // Shift view up by 120px when keyboard is active to keep runner in view
    const targetCameraY = window.mobileControlsActive ? -120 : 0;
    this.cameraY += (targetCameraY - this.cameraY) * 0.1;
  }
};

PolyRaceScene.updatePlayers=function(){
  if(this.STATE==="running"){
    this.raceTime = ((Date.now() - this.raceStartTime) / 1000).toFixed(1);
    document.getElementById('time-display').textContent = `${this.raceTime}s`;

    // Check for idle timeout
    const timeSinceActivity = Date.now() - this.lastActivityTime;
    if(timeSinceActivity > this.idleTimeout && !this.isIdle){
      console.log('[IDLE] User inactive for', timeSinceActivity, 'ms - ending game');
      this.isIdle = true;
      this.STATE = "idle";
      this.showIdleOverlay();
      return;
    }

    this.players.forEach(p=>{
      p.checkKeyPress();
      p.checkWin();
    });
    this.updateKeyIndicator();
    this.updateCamera();
  }
  this.players.forEach(p=>p.update());
};

// OPTIMIZED: Reduced fog layers and grid complexity
PolyRaceScene.renderBackground=function(){
  const ctx=this.ctx, W=this.world.W, H=this.world.H;

  // OPTIMIZED: Reduced from 3 to 2 fog layers
  this.atmosphereOffset += 0.002;
  for(let i = 0; i < 2; i++) {
    ctx.save();
    ctx.globalAlpha = 0.1 - i * 0.03; // Reduced opacity
    const parallaxOffset = -this.cameraX * (0.2 + i * 0.1);
    const offset = Math.sin(this.atmosphereOffset + i * 0.5) * 50;
    const grad = ctx.createRadialGradient(W/2 + offset + parallaxOffset, H * 0.3, 50, W/2 + offset + parallaxOffset, H * 0.3, 400);
    grad.addColorStop(0, "#00ffff");
    grad.addColorStop(1, "transparent");
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, W, H);
    ctx.restore();
  }

  ctx.save();
  ctx.translate(-this.cameraX, this.cameraY);

  ctx.save();
  ctx.strokeStyle="rgba(0,255,255,0.2)";
  ctx.lineWidth=1.5;

  const horizonY = H * 0.4;
  const groundY = H * 0.85;
  const cell = 80; // INCREASED from 60 for fewer lines

  // OPTIMIZED: Reduced from 20 to 12 horizontal lines
  for(let i = 0; i < 12; i++){
    const t = i / 12;
    const y = horizonY + (groundY - horizonY) * (t * t);
    const alpha = 0.1 + t * 0.35;
    ctx.globalAlpha = alpha;
    ctx.beginPath();
    const lineStartX = this.cameraX - W;
    const lineEndX = this.cameraX + W * 3;
    ctx.moveTo(lineStartX, y);
    ctx.lineTo(lineEndX, y);
    ctx.stroke();
  }

  // OPTIMIZED: Reduced vertical lines from -5 to 30 -> -3 to 20
  const gridOffset = Math.floor(this.cameraX / cell) * cell;
  for(let i = -3; i < 20; i++){
    ctx.globalAlpha = 0.25;
    ctx.beginPath();
    const baseX = gridOffset + i * cell;
    ctx.moveTo(baseX, horizonY);
    ctx.lineTo(baseX, groundY);
    ctx.stroke();
  }
  ctx.restore();

  // OPTIMIZED: Reduced from 8 to 4 speed lines
  if(this.STATE === "running"){
    ctx.save();
    ctx.strokeStyle = "rgba(0,255,255,0.15)";
    ctx.lineWidth = 2;
    for(let i = 0; i < 4; i++){
      const y = H * 0.3 + i * 120; // Increased spacing
      const speed = (Date.now() * 0.5 + i * 100) % 1000;
      const startX = this.cameraX + W - speed;
      const endX = startX - 100;
      ctx.globalAlpha = 0.3 - (speed / 1000) * 0.3;
      ctx.beginPath();
      ctx.moveTo(startX, y);
      ctx.lineTo(endX, y);
      ctx.stroke();
    }
    ctx.restore();
  }

  // Finish line with glow and animation
  const finishX = this.players[0].startX + this.raceDistancePixels;

  // Pulsing glow effect
  const glowIntensity = (Math.sin(Date.now() * 0.005) + 1) * 0.5; // 0 to 1

  ctx.save();

  // Add glowing aura behind finish line
  ctx.shadowColor = "#00ffff";
  ctx.shadowBlur = 30 + glowIntensity * 20;
  ctx.globalAlpha = 0.6 + glowIntensity * 0.2;

  const topWidth = 40;
  const bottomWidth = 120;
  const rows = 12;
  const cols = 3;

  for(let row = 0; row < rows; row++) {
    const t = row / rows;
    const nextT = (row + 1) / rows;

    const y1 = horizonY + (groundY - horizonY) * (t * t);
    const y2 = horizonY + (groundY - horizonY) * (nextT * nextT);

    const width1 = topWidth + (bottomWidth - topWidth) * t;
    const width2 = topWidth + (bottomWidth - topWidth) * nextT;

    const colWidth1 = width1 / cols;
    const colWidth2 = width2 / cols;

    for(let col = 0; col < cols; col++) {
      const isWhite = (row + col) % 2 === 0;

      const x1_left = finishX - width1/2 + col * colWidth1;
      const x1_right = finishX - width1/2 + (col + 1) * colWidth1;
      const x2_left = finishX - width2/2 + col * colWidth2;
      const x2_right = finishX - width2/2 + (col + 1) * colWidth2;

      ctx.globalAlpha = 0.15 + t * 0.25;
      ctx.fillStyle = isWhite ? '#ffffff' : '#000000';
      ctx.beginPath();
      ctx.moveTo(x1_left, y1);
      ctx.lineTo(x1_right, y1);
      ctx.lineTo(x2_right, y2);
      ctx.lineTo(x2_left, y2);
      ctx.closePath();
      ctx.fill();
    }
  }

  ctx.globalAlpha = 0.3;
  ctx.strokeStyle = '#00ffff';
  ctx.lineWidth = 2;
  ctx.shadowColor = '#00ffff';
  ctx.shadowBlur = 15;

  ctx.beginPath();
  ctx.moveTo(finishX - topWidth/2, horizonY);
  ctx.lineTo(finishX - bottomWidth/2, groundY);
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(finishX + topWidth/2, horizonY);
  ctx.lineTo(finishX + bottomWidth/2, groundY);
  ctx.stroke();

  ctx.globalAlpha = 0.15;
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(finishX - topWidth/2, horizonY);
  ctx.lineTo(finishX + topWidth/2, horizonY);
  ctx.stroke();

  ctx.globalAlpha = 0.35;
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(finishX - bottomWidth/2, groundY);
  ctx.lineTo(finishX + bottomWidth/2, groundY);
  ctx.stroke();

  ctx.restore();

  ctx.restore();
};

PolyRaceScene.showWinScreen=function(){
  if(this.STATE !== "win") return;

  const winTitle = document.getElementById('win-title');
  const winTime = document.getElementById('win-time');
  const winScore = document.getElementById('win-score');
  const winCombo = document.getElementById('win-combo');

  const winnerColor = this.players[this.winner].color;

  winTitle.textContent = `PLAYER ${this.winner + 1} WINS!`;
  winTitle.style.color = winnerColor;

  winTime.textContent = `Time: ${this.raceTime}s`;
  winScore.textContent = `Score: ${this.winnerStats.score}`;
  winCombo.textContent = `Max Combo: ${this.winnerStats.maxCombo}`;

  this.updateUIState();
  this.canRestart = true;
};

PolyRaceScene.showIdleOverlay=function(){
  if(this.STATE !== "idle") return;

  const idleStats = document.getElementById('idle-stats');
  const player = this.players[0];

  if(player){
    idleStats.textContent = `Score: ${player.score} | Progress: ${Math.floor(player.progressPercent)}%`;
  }

  this.updateUIState();
  this.canRestart = true;
};

PolyRaceScene.render=function(){
  if(this.STATE==="countdown") {
    this.updateCountdown();
    if(this.countStart){
      this.showCountdownText(this.countSeq[this.countIndex]);
    }
  }

  this.updatePlayers();

  this.world.clear();
  this.renderBackground();

  const ctx = this.ctx;
  ctx.save();
  ctx.translate(-this.cameraX, this.cameraY);
  this.players.forEach(p=>p.draw());

  if (this.selectedMode === "online" && this.STATE === "running") {
    this.players.forEach(p => this.drawUsername(p));
  }

  ctx.restore();

  if(this.STATE === "win" && !this.canRestart){
    this.showWinScreen();
  }
};

PolyRaceScene.drawUsername=function(player){
  if (!player || !player.username) return;

  const ctx = this.ctx;
  const pos = player.body.position;

  ctx.save();

  const usernameY = pos.y - 180;

  ctx.font = "bold 16px 'Orbitron'";
  ctx.textAlign = "center";
  const textWidth = ctx.measureText(player.username).width;
  const padding = 8;

  ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
  ctx.fillRect(
    pos.x - textWidth/2 - padding,
    usernameY - 14,
    textWidth + padding * 2,
    22
  );

  ctx.strokeStyle = player.color;
  ctx.lineWidth = 2;
  ctx.strokeRect(
    pos.x - textWidth/2 - padding,
    usernameY - 14,
    textWidth + padding * 2,
    22
  );

  ctx.fillStyle = player.color;
  ctx.shadowColor = player.color;
  ctx.shadowBlur = 10;
  ctx.fillText(player.username, pos.x, usernameY);

  ctx.restore();
};

// ============================================
// Game World with Mobile FPS Limiting
// ============================================
class GameWorld {
  constructor(){
    this.canvas=document.getElementById("game-canvas");
    this.ctx=this.canvas.getContext("2d");
    this.ctx.imageSmoothingEnabled=false;
    this.resize();
    window.addEventListener('resize',()=>this.resize());

    if (window.visualViewport) {
      window.visualViewport.addEventListener('resize', () => this.resize());
    }
    this.keys={};
    this.keyBuffer = {};
    document.addEventListener("keydown",e=>this.onKeyDown(e));
    document.addEventListener("keyup",e=>this.onKeyUp(e));
    this.FPS={now:0,delta:0,last:Util.timeStamp(),step:1/60};
    this.scenes={}; this.current_scene=null;

    // OPTIMIZED: Mobile FPS limiter
    this.isMobile = /Android|webOS|iPhone|iPad|iPod/i.test(navigator.userAgent);
    this.targetFPS = this.isMobile ? 30 : 60;
    this.frameTime = 1000 / this.targetFPS;
    this.lastFrameTime = 0;

    try {
      this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    } catch(e) {
      console.log("Audio not supported");
    }
  }
  resize(){
    this.W=window.innerWidth;

    // When mobile controls are active, maintain full height
    // Otherwise use Visual Viewport API
    if (window.mobileControlsActive) {
      // Keep canvas at full height - keyboard is overlaid on top
      this.H = window.innerHeight;
    } else if (window.visualViewport) {
      // Use Visual Viewport API for non-mobile or when keyboard isn't showing
      this.H = window.visualViewport.height;
    } else {
      this.H = window.innerHeight;
    }

    this.canvas.width=this.W;
    this.canvas.height=this.H;
  }
  addScene(scene){ scene.giveWorld(this); this.scenes[scene.name]=scene; }
  startScene(name){
    this.current_scene=this.scenes[name];
    if(!this.current_scene.init_once){
      this.current_scene.init();
      this.current_scene.init_once=true;
    } else {
      this.current_scene.init_once = false;
      this.current_scene.init();
      this.current_scene.init_once = true;
    }
    this.loop();
  }
  // OPTIMIZED: FPS limiter for mobile
  loop(){
    const now = Util.timeStamp();
    
    // FPS limiter for mobile
    if (this.isMobile && now - this.lastFrameTime < this.frameTime) {
      requestAnimationFrame(() => this.loop());
      return;
    }
    this.lastFrameTime = now;
    
    this.FPS.now=now;
    this.FPS.delta+=Math.min(1,(this.FPS.now-this.FPS.last)/1000);
    while(this.FPS.delta>this.FPS.step){
      this.FPS.delta-=this.FPS.step;
      this.render();
    }
    this.FPS.last=this.FPS.now;
    requestAnimationFrame(()=>this.loop());
  }
  render(){ if(this.current_scene)this.current_scene.render(); }
  clear(){ this.ctx.fillStyle="#000"; this.ctx.fillRect(0,0,this.W,this.H); }
  onKeyDown(e){
    const key = e.key.toLowerCase();
    if(!this.keyBuffer[key]) {
      this.keys[key]=true;
      this.keyBuffer[key]=true;
      if(this.current_scene&&this.current_scene.keyEvents)this.current_scene.keyEvents(e);
    }
    if(['a','s','d','f','g','h','j','k','l','u','i','o',' ','Escape','1','2'].includes(e.key)){
      e.preventDefault();
    }
  }
  onKeyUp(e){
    const key = e.key.toLowerCase();
    this.keys[key]=false;
    this.keyBuffer[key]=false;
  }
}

const game = new GameWorld();
game.addScene(PolyRaceScene);
game.startScene("PolyRace");
  </script>

  <!-- Socket.IO Client Library -->
  <script src="/socket.io/socket.io.js"></script>

  <!-- OPTIMIZED Multiplayer Sync -->
  <script>
console.log('[GAME] Multiplayer script starting...');

const urlParams = new URLSearchParams(window.location.search);
const mode = urlParams.get("mode");
const roomFromURL = urlParams.get("room");

console.log('[GAME] Mode:', mode);
console.log('[GAME] Room from URL:', roomFromURL);

if (mode === "online") {
  console.log('[MP] ===== MULTIPLAYER MODE DETECTED =====');

  if (typeof io === 'undefined') {
    console.error('[MP] ERROR: Socket.IO library not loaded!');
    alert('ERROR: Socket.IO library failed to load. Check your internet connection.');
  } else {
    console.log('[MP] Socket.IO library loaded successfully');
  }

  const serverUrl = window.location.origin;
  console.log('[MP] Connecting to:', serverUrl);

  const socket = io(serverUrl, {
    transports: ['websocket', 'polling'],
    reconnection: true,
    reconnectionAttempts: 5
  });

  console.log('[MP] Socket created:', socket);
  window.multiplayerSocket = socket;

  let roomCode = urlParams.get("room");
  const playerName = localStorage.getItem("username") || `Player${Math.floor(Math.random() * 10000)}`;

  let mySocketId = null;
  let myPlayerIndex = null;
  let opponentPlayerIndex = null;
  let roomData = null;

  if (roomCode) {
    sessionStorage.setItem('currentRoomCode', roomCode);
  }

  console.log(`[MP] Joining room ${roomCode} as ${playerName}`);

  socket.on("connect", () => {
    console.log("[MP] Connected:", socket.id);
    mySocketId = socket.id;

    if (socket.recovered) {
      console.log("[MP] Connection recovered - already in room");
      return;
    }

    if (!roomCode) {
      roomCode = sessionStorage.getItem('currentRoomCode');
      console.log("[MP] Restored room code from session:", roomCode);
    }

    console.log("[MP] Emitting player:register...");
    socket.emit("player:register", { name: playerName });

    if (roomCode) {
      console.log("[MP] Emitting room:join with code:", roomCode);
      socket.emit("room:join", { roomCode });
    } else {
      console.error("[MP] No room code provided!");
    }
  });

  socket.on("disconnect", (reason) => {
    console.log("[MP] Disconnected:", reason);

    const waitingRoom = document.getElementById('online-waiting-room');
    if (waitingRoom && waitingRoom.classList.contains('active')) {
      const readyHint = document.getElementById('ready-hint');
      if (readyHint) {
        readyHint.textContent = 'Connection lost... Reconnecting...';
        readyHint.style.color = '#ff00ff';
      }
    }
  });

  socket.on("reconnect", (attemptNumber) => {
    console.log("[MP] Reconnected after", attemptNumber, "attempts");

    const savedRoomCode = sessionStorage.getItem('currentRoomCode');
    if (savedRoomCode && !socket.recovered) {
      console.log("[MP] Attempting to rejoin room:", savedRoomCode);
      socket.emit("player:register", { name: playerName });
      socket.emit("room:join", { roomCode: savedRoomCode });
    }

    const readyHint = document.getElementById('ready-hint');
    if (readyHint) {
      readyHint.textContent = 'Reconnected! Waiting for opponent...';
      readyHint.style.color = '#00ff88';
    }
  });

  socket.on("room:joined", (data) => {
    console.log("[MP] Joined room:", data);
    roomData = data.room;
    myPlayerIndex = data.playerIndex;
    opponentPlayerIndex = myPlayerIndex === 0 ? 1 : 0;

    sessionStorage.setItem('currentRoomCode', data.room.code);
    sessionStorage.setItem('myPlayerIndex', myPlayerIndex);

    console.log(`[MP] I am player ${myPlayerIndex}`);

    const scene = game?.current_scene;
    if (scene && scene.players) {
      const myData = roomData.players[myPlayerIndex];
      const opponentData = roomData.players[opponentPlayerIndex];

      if (scene.players[0] && myData) {
        scene.players[0].username = myData.name;
        scene.players[0].color = myPlayerIndex === 0 ? '#00ffff' : '#ff00ff';
        console.log(`[MP] Local player: ${myData.name} (${scene.players[0].color})`);
      }

      if (scene.players[1] && opponentData) {
        scene.players[1].username = opponentData.name;
        scene.players[1].color = opponentPlayerIndex === 0 ? '#00ffff' : '#ff00ff';
        console.log(`[MP] Opponent: ${opponentData.name} (${scene.players[1].color})`);
      }
    }

    showWaitingRoom(roomData);
  });

  function showWaitingRoom(room) {
    console.log('[MP] showWaitingRoom called with:', room);

    const waitingRoom = document.getElementById('online-waiting-room');
    const inviteLinkInput = document.getElementById('game-invite-link');
    const copyBtn = document.getElementById('copy-game-link-btn');
    const readyBtn = document.getElementById('im-ready-btn');
    const readyHint = document.getElementById('ready-hint');

    const inviteLink = `${window.location.origin}/game.html?mode=online&room=${roomCode}`;
    inviteLinkInput.value = inviteLink;

    let copyHandlerAdded = false;
    if (!copyHandlerAdded) {
      copyBtn.addEventListener('click', async () => {
        try {
          await navigator.clipboard.writeText(inviteLink);
          const origHTML = copyBtn.innerHTML;
          copyBtn.innerHTML = '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"></polyline></svg> COPIED!';
          copyBtn.style.borderColor = '#00ff88';
          copyBtn.style.color = '#00ff88';
          setTimeout(() => {
            copyBtn.innerHTML = origHTML;
            copyBtn.style.borderColor = '';
            copyBtn.style.color = '';
          }, 2000);
        } catch (err) {
          console.error('[MP] Failed to copy:', err);
        }
      });
      copyHandlerAdded = true;
    }

    let modeHandlerAdded = false;
    if (!modeHandlerAdded) {
      let selectedGameMode = 'letters';

      document.querySelectorAll('.mode-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          selectedGameMode = btn.dataset.mode;
          console.log('[MP] Game mode selected:', selectedGameMode);
          sessionStorage.setItem('selectedGameMode', selectedGameMode);
        });
      });

      modeHandlerAdded = true;
    }

    updatePlayerStatus(room);

    console.log('[MP] Showing waiting room...');
    waitingRoom.classList.add('active');

    let readyHandlerAdded = false;
    if (!readyHandlerAdded) {
      readyBtn.addEventListener('click', () => {
        console.log('[MP] Clicked READY');
        socket.emit('player:ready');
        readyBtn.disabled = true;
        readyBtn.innerHTML = '<span class="btn-text">WAITING FOR OPPONENT...</span>';
        readyHint.textContent = 'Waiting for other player...';
      });
      readyHandlerAdded = true;
    }
  }

  function updatePlayerStatus(room) {
    if (!room || !room.players) return;

    const player1Status = document.getElementById('player1-status');
    const player2Status = document.getElementById('player2-status');
    const player1Name = document.getElementById('player1-name');
    const player2Name = document.getElementById('player2-name');
    const player1Badge = document.getElementById('player1-badge');
    const player2Badge = document.getElementById('player2-badge');
    const readyBtn = document.getElementById('im-ready-btn');
    const readyHint = document.getElementById('ready-hint');

    if (room.players.length >= 1) {
      const p1 = room.players[0];
      player1Name.textContent = p1.name;
      player1Badge.textContent = p1.ready ? 'READY' : 'WAITING...';
      player1Badge.className = 'player-status-badge ' + (p1.ready ? 'ready' : 'waiting');
      if (p1.ready) player1Status.classList.add('ready');
      else player1Status.classList.remove('ready');
    }

    if (room.players.length >= 2) {
      const p2 = room.players[1];
      player2Name.textContent = p2.name;
      player2Badge.textContent = p2.ready ? 'READY' : 'WAITING...';
      player2Badge.className = 'player-status-badge ' + (p2.ready ? 'ready' : 'waiting');
      if (p2.ready) player2Status.classList.add('ready');
      else player2Status.classList.remove('ready');

      if (!room.players[myPlayerIndex]?.ready) {
        readyBtn.disabled = false;
        readyHint.textContent = 'Click when ready to race!';
      }
    } else {
      player2Name.textContent = 'Waiting for player...';
      player2Badge.textContent = 'EMPTY';
      player2Badge.className = 'player-status-badge empty';
      player2Status.classList.remove('ready');

      readyBtn.disabled = true;
      readyHint.textContent = 'Waiting for opponent to join...';
    }
  }

  socket.on("room:updated", (data) => {
    console.log("[MP] Room updated:", data.room);
    roomData = data.room;
    updatePlayerStatus(roomData);
  });

  socket.on("game:countdown-start", (data) => {
    console.log("[MP] Countdown starting!", data);
    roomData = data.room;

    const waitingRoom = document.getElementById('online-waiting-room');
    waitingRoom.classList.remove('active');

    const serverCountdownStart = data.countdownStartTime;
    const now = Date.now();
    const clientDelay = now - serverCountdownStart;

    console.log(`[MP] Countdown started ${clientDelay}ms ago (latency compensation)`);

    const scene = game.current_scene;
    if (scene) {
      console.log("[MP] Setting scene to countdown state");
      scene.STATE = "countdown";
      scene.countIndex = 0;
      scene.countStart = new Date(serverCountdownStart);

      if (!scene.players || scene.players.length === 0) {
        console.log("[MP] Initializing players for countdown");
        scene.initPlayers();
      }

      scene.updateUIState();
      scene.startCountdown();

      console.log("[MP] Countdown initialized, players:", scene.players.length);
    } else {
      console.error("[MP] No scene found for countdown!");
    }
  });

  socket.on("game:race-start", (data) => {
    console.log("[MP] Race starting NOW!");

    const scene = game.current_scene;
    if (scene) {
      console.log("[MP] Transitioning to running state");
      scene.STATE = "running";
      scene.raceStartTime = data.room.startTime;

      if (scene.players && scene.players.length > 0) {
        scene.players.forEach((p, idx) => {
          console.log(`[MP] Player ${idx}: position=${p.body.position.x}, progress=${p.progressPercent}`);
        });
      }

      scene.updateUIState();
      console.log("[MP] Race started! STATE:", scene.STATE, "Players:", scene.players.length);
    } else {
      console.error("[MP] No scene when race started!");
    }
  });

  // OPTIMIZED: Reduced update frequency from 100ms to 150ms
  const SEND_INTERVAL = 150;
  let lastSendTime = 0;

  function sendPositionUpdate() {
    const now = Date.now();
    if (now - lastSendTime < SEND_INTERVAL) return; // Throttle
    lastSendTime = now;

    const scene = game.current_scene;
    if (!scene || scene.STATE !== "running") return;

    const me = scene.players[0];
    if (!me) return;

    socket.emit("player:update", {
      position: Math.round(me.body.position.x), // Round to reduce precision
      progress: Math.round(me.progressPercent),
      score: me.score,
      combo: me.combo,
      animTime: me.animTime,
      velocity: Math.round(me.body.velocity.x * 10) / 10
    });
  }

  setInterval(sendPositionUpdate, SEND_INTERVAL);

  // OPTIMIZED: Lighter interpolation with snap threshold
  socket.on("game:update", (data) => {
    const scene = game.current_scene;
    if (!scene || scene.STATE !== "running") return;

    const opponent = scene.players[1];
    if (!opponent) return;

    const targetX = data.position ?? opponent.body.position.x;
    const deltaX = Math.abs(targetX - opponent.body.position.x);
    
    if (deltaX > 1) {
      opponent.body.position.x += (targetX - opponent.body.position.x) * 0.2; // Reduced from 0.3
    } else {
      opponent.body.position.x = targetX; // Snap if close
    }

    opponent.progressPercent = data.progress ?? 0;
    opponent.score = data.score ?? 0;
    opponent.combo = data.combo ?? 0;
    opponent.animTime = data.animTime ?? 0;
    opponent.body.velocity.x = data.velocity ?? 0;
  });

  socket.on("game:finished", (data) => {
    console.log("[MP] Game finished!", data.winner);

    const scene = game.current_scene;
    if (scene && scene.STATE === "running") {
      scene.STATE = "win";

      if (data.winner.socketId === mySocketId) {
        scene.winner = 0;
      } else {
        scene.winner = 1;
      }

      scene.winnerStats = {
        score: data.winner.score || 0,
        maxCombo: scene.players[scene.winner]?.maxCombo || 0
      };

      scene.showWinScreen();
    }
  });

  socket.on("room:player-left", (data) => {
    console.log("[MP] Player left:", data.playerName);

    const scene = game.current_scene;
    if (!scene) return;

    if (scene.STATE === "running") {
      console.log("[MP] Opponent disconnected during race!");

      const previousState = scene.STATE;
      scene.STATE = "paused";

      showOpponentDisconnectedOverlay(data.playerName, () => {
        window.location.href = window.location.origin + '/';
      });
    } else if (scene.STATE === "waiting") {
      console.log("[MP] Player left waiting room");
      const waitingRoom = document.getElementById('online-waiting-room');
      if (waitingRoom && waitingRoom.style.opacity === '1') {
        updateWaitingRoomPlayers(data.room);
      }
    }
  });

  function showOpponentDisconnectedOverlay(opponentName, onReturnToLobby) {
    const existingOverlay = document.getElementById('opponent-disconnected-overlay');
    if (existingOverlay) existingOverlay.remove();

    const overlay = document.createElement('div');
    overlay.id = 'opponent-disconnected-overlay';
    overlay.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.95);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      font-family: 'Orbitron', sans-serif;
    `;

    overlay.innerHTML = `
      <div style="text-align: center; max-width: 600px; padding: 40px;">
        <div style="font-size: 4rem; margin-bottom: 20px;">‚ö†Ô∏è</div>
        <h2 style="font-size: 2rem; color: #FFD700; letter-spacing: 4px; margin-bottom: 20px; text-shadow: 0 0 20px #FFD700;">
          OPPONENT DISCONNECTED
        </h2>
        <p style="font-size: 1.2rem; color: rgba(255,255,255,0.8); margin-bottom: 15px;">
          <strong style="color: #00ffff;">${opponentName}</strong> has left the game.
        </p>
        <p style="font-size: 0.9rem; color: rgba(255,255,255,0.5); margin-bottom: 40px; line-height: 1.6;">
          The race has been paused. You can wait for them to rejoin or return to the lobby.
        </p>
        <div style="display: flex; gap: 20px; justify-content: center;">
          <button id="wait-reconnect-btn" style="
            padding: 15px 30px;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9rem;
            font-weight: 700;
            letter-spacing: 3px;
            background: transparent;
            border: 2px solid #00ffff;
            color: #00ffff;
            cursor: pointer;
            transition: all 0.3s ease;
            text-shadow: 0 0 10px #00ffff;
          ">WAIT (60s)</button>
          <button id="return-lobby-btn" style="
            padding: 15px 30px;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9rem;
            font-weight: 700;
            letter-spacing: 3px;
            background: transparent;
            border: 2px solid rgba(255,255,255,0.3);
            color: rgba(255,255,255,0.7);
            cursor: pointer;
            transition: all 0.3s ease;
          ">RETURN TO LOBBY</button>
        </div>
        <p id="reconnect-timer" style="
          margin-top: 20px;
          font-size: 0.8rem;
          color: rgba(255,255,255,0.4);
          display: none;
        ">Waiting for reconnection...</p>
      </div>
    `;

    document.body.appendChild(overlay);

    document.getElementById('return-lobby-btn').addEventListener('click', () => {
      overlay.remove();
      if (onReturnToLobby) onReturnToLobby();
    });

    let waitTimeout;
    document.getElementById('wait-reconnect-btn').addEventListener('click', () => {
      const timerText = document.getElementById('reconnect-timer');
      timerText.style.display = 'block';

      let countdown = 60;
      const waitBtn = document.getElementById('wait-reconnect-btn');
      waitBtn.disabled = true;
      waitBtn.style.opacity = '0.5';

      const countdownInterval = setInterval(() => {
        countdown--;
        timerText.textContent = `Waiting for reconnection... ${countdown}s`;

        if (countdown <= 0) {
          clearInterval(countdownInterval);
          timerText.textContent = 'Opponent did not rejoin. Returning to lobby...';
          setTimeout(() => {
            overlay.remove();
            if (onReturnToLobby) onReturnToLobby();
          }, 2000);
        }
      }, 1000);

      const checkReconnect = setInterval(() => {
        const scene = game.current_scene;
        if (scene && scene.players.length >= 2) {
          clearInterval(countdownInterval);
          clearInterval(checkReconnect);
          overlay.remove();
          scene.STATE = "running";
          console.log("[MP] Opponent rejoined! Resuming game.");
        }
      }, 500);
    });
  }

  socket.on("room:reset", (data) => {
    console.log("[MP] Room reset for rematch!");
    roomData = data.room;

    const winScreen = document.getElementById('win-screen');
    winScreen?.classList.remove('active');

    const scene = game.current_scene;
    if (scene) {
      scene.STATE = "menu";
      scene.winner = null;
      scene.canRestart = false;
      scene.updateUIState();

      scene.players.forEach(p => {
        p.body.position.x = p.startX;
        p.score = 0;
        p.combo = 0;
        p.progressPercent = 0;
        p.hasFinished = false;
      });
    }

    showWaitingRoom(roomData);

    const readyBtn = document.getElementById('im-ready-btn');
    if (readyBtn) {
      readyBtn.disabled = roomData.players.length < 2;
      readyBtn.innerHTML = '<span class="btn-text">I\'M READY</span>';
    }
  });

  socket.on("room:error", (data) => {
    console.error("[MP] Room error:", data.message);
    alert("Room error: " + data.message);
    window.location.href = "modes.html";
  });

  socket.on("disconnect", () => {
    console.log("[MP] Disconnected from server");
  });

  socket.on("connect_error", (error) => {
    console.error("[MP] Connection error:", error);
  });

  window.addEventListener('beforeunload', () => {
    const scene = game.current_scene;
    if (scene && scene.STATE === "running") {
      const me = scene.players[0];
      if (me && me.progressPercent >= 100) {
        socket.emit("player:finished");
      }
    }
  });
}
  </script>

  <!-- Global online tracking (for all game modes) -->
  <script>
    const urlParams2 = new URLSearchParams(window.location.search);
    const gameMode = urlParams2.get("mode");

    if (gameMode !== "online") {
      (function() {
        const serverUrl = window.location.origin;

        let anonymousId = localStorage.getItem('anonymousId');
        if (!anonymousId) {
          anonymousId = 'Guest_' + Math.random().toString(36).substr(2, 9);
          localStorage.setItem('anonymousId', anonymousId);
        }

        try {
          const backgroundSocket = io(serverUrl, {
            transports: ['websocket', 'polling'],
            reconnection: true
          });

          backgroundSocket.on('connect', () => {
            console.log('[GAME] Background connection established:', backgroundSocket.id);

            backgroundSocket.emit('player:register', {
              name: anonymousId,
              isVisitor: true
            });
          });

          backgroundSocket.on('disconnect', () => {
            console.log('[GAME] Background disconnected');
          });

          window.addEventListener('beforeunload', () => {
            if (backgroundSocket && backgroundSocket.connected) {
              backgroundSocket.disconnect();
            }
          });

        } catch (error) {
          console.error('[GAME] Background connection failed:', error);
        }
      })();
    }
  </script>
</body>
</html>"
