<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>POLY RACE - Type. Race. Win.</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
  <style>
    /* POLY RACE - Minimalistic Neon Game Theme */

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --cyan: #00ffff;
      --magenta: #ff00ff;
      --gold: #FFD700;
      --void: #000000;
      --dark: #0a0a0f;
    }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      overflow: hidden;
      background: radial-gradient(ellipse at center, #0a0a0f 0%, #000000 100%);
      font-family: 'Orbitron', sans-serif;
      color: #fff;
    }

    /* Fade-in animation */
    body {
      animation: fadeIn 0.8s ease-in;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }

    /* Loading overlay */
    #loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
      opacity: 1;
      pointer-events: none;
      z-index: 9999;
      transition: opacity 0.8s ease-in-out;
    }

    #loading-overlay.fade-out {
      opacity: 0;
    }

    /* Canvas container */
    #game-canvas {
      width: 100vw;
      height: 100vh;
      display: block;
      background: transparent;
    }

    /* Game HUD Overlay */
    #game-hud {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 100;
    }

    /* Title Card (for menu state) */
    #title-card {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 200;
    }

    .game-title {
      font-size: 6rem;
      font-weight: 900;
      letter-spacing: 15px;
      text-transform: uppercase;
      color: #fff;
      text-shadow:
        0 0 40px var(--cyan),
        0 0 80px var(--cyan),
        0 0 120px rgba(0, 255, 255, 0.3);
      margin-bottom: 1rem;
      line-height: 0.9;
    }

    .game-subtitle {
      font-size: 1.1rem;
      color: rgba(255, 255, 255, 0.5);
      letter-spacing: 6px;
      font-weight: 400;
      text-transform: uppercase;
      margin-bottom: 2rem;
    }

    .game-instruction {
      font-size: 0.9rem;
      color: rgba(0, 255, 255, 0.8);
      letter-spacing: 3px;
      font-weight: 600;
      text-shadow: 0 0 20px var(--cyan);
      animation: pulse 2s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% {
        opacity: 1;
      }
      50% {
        opacity: 0.6;
      }
    }

    /* Game Stats HUD */
    #stats-hud {
      position: absolute;
      top: 30px;
      width: 100%;
      display: flex;
      justify-content: center;
      gap: 60px;
      pointer-events: none;
    }

    .stat-display {
      text-align: center;
    }

    .stat-label {
      font-size: 0.75rem;
      color: rgba(255, 255, 255, 0.4);
      letter-spacing: 2px;
      font-weight: 500;
      margin-bottom: 5px;
    }

    .stat-value {
      font-size: 1.5rem;
      font-weight: 700;
      letter-spacing: 2px;
      text-shadow: 0 0 15px currentColor;
    }

    .stat-value.cyan {
      color: var(--cyan);
    }

    .stat-value.magenta {
      color: var(--magenta);
    }

    .stat-value.gold {
      color: var(--gold);
    }

    /* Key Indicators */
    #key-indicator {
      position: absolute;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 60px;
      pointer-events: none;
    }

    .player-keys {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
    }

    .player-label {
      font-size: 0.75rem;
      font-weight: 600;
      letter-spacing: 3px;
      text-shadow: 0 0 15px currentColor;
      opacity: 0.8;
    }

    .key-display {
      font-size: 2.5rem;
      font-weight: 800;
      padding: 20px 30px;
      border: 3px solid;
      border-radius: 8px;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(10px);
      min-width: 80px;
      text-align: center;
      box-shadow: 0 0 30px currentColor;
      transition: all 0.15s ease;
      letter-spacing: 2px;
    }

    .key-display.pressed {
      transform: scale(1.15);
      box-shadow: 0 0 50px currentColor;
      background: rgba(0, 0, 0, 0.95);
    }

    /* Win Screen */
    #win-screen {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 300;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s ease;
    }

    #win-screen.active {
      opacity: 1;
      pointer-events: all;
    }

    .win-title {
      font-size: 5rem;
      font-weight: 900;
      letter-spacing: 12px;
      margin-bottom: 1rem;
      text-shadow: 0 0 60px currentColor;
    }

    .win-stats {
      font-size: 1.2rem;
      color: rgba(255, 255, 255, 0.7);
      letter-spacing: 3px;
      margin: 0.5rem 0;
    }

    .win-restart {
      margin-top: 2rem;
      font-size: 0.9rem;
      color: var(--cyan);
      letter-spacing: 3px;
      text-shadow: 0 0 20px var(--cyan);
      animation: pulse 2s ease-in-out infinite;
    }

    /* Countdown */
    #countdown-display {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-family: 'Orbitron', sans-serif;
      font-size: 10rem;
      font-weight: 900;
      color: #00ffff;
      text-shadow:
        0 0 40px #00ffff,
        0 0 80px #00ffff,
        0 0 120px rgba(0, 255, 255, 0.5);
      z-index: 2500;
      opacity: 0;
      pointer-events: none;
      letter-spacing: 8px;
    }

    #countdown-display.active {
      animation: countdownPulse 1s ease-in-out;
    }

    @keyframes countdownPulse {
      0% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.3);
      }
      40% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1.3);
      }
      70% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1.1);
      }
      100% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(1.5);
      }
    }

    /* Mobile Touch Controls */
    #mobile-controls {
      display: none;
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      padding: 15px;
      background: linear-gradient(to top, rgba(0,0,0,0.98) 0%, rgba(0,0,0,0.9) 80%, transparent 100%);
      z-index: 150;
      pointer-events: none;
    }

    #mobile-controls.active {
      display: flex;
      flex-direction: column;
      align-items: center;
      pointer-events: all;
    }

    .mobile-hint {
      font-size: 0.7rem;
      color: rgba(255, 255, 255, 0.5);
      letter-spacing: 2px;
      text-align: center;
      margin-bottom: 10px;
      text-transform: uppercase;
    }

    /* Home Row Keyboard (for letter modes) */
    .home-row-keyboard {
      display: flex;
      gap: 8px;
      justify-content: center;
      flex-wrap: wrap;
      max-width: 100%;
      padding: 0 10px;
    }

    .key-button {
      padding: 18px 14px;
      font-family: 'Orbitron', sans-serif;
      font-size: 1.4rem;
      font-weight: 800;
      letter-spacing: 2px;
      color: rgba(255, 255, 255, 0.6);
      background: rgba(0, 0, 0, 0.8);
      border: 2px solid rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      cursor: pointer;
      user-select: none;
      -webkit-user-select: none;
      -webkit-tap-highlight-color: transparent;
      transition: all 0.15s ease;
      min-width: 50px;
      text-align: center;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    .key-button.active {
      color: var(--cyan);
      border-color: var(--cyan);
      background: rgba(0, 255, 255, 0.1);
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.4);
      text-shadow: 0 0 10px var(--cyan);
    }

    .key-button:active {
      transform: scale(0.95);
      box-shadow: 0 0 30px var(--cyan);
    }

    .key-button.disabled {
      opacity: 0.3;
      pointer-events: none;
    }

    /* Full QWERTY Keyboard (for word/story modes) */
    .full-keyboard {
      display: flex;
      flex-direction: column;
      gap: 6px;
      width: 100%;
      max-width: 600px;
      padding: 0 5px;
    }

    .keyboard-row {
      display: flex;
      gap: 4px;
      justify-content: center;
    }

    .full-keyboard .key-button {
      padding: 14px 8px;
      font-size: 1.1rem;
      min-width: 40px;
      flex: 1;
      max-width: 50px;
    }

    .full-keyboard .key-button.space {
      flex: 3;
      max-width: none;
      font-size: 0.8rem;
    }

    /* Viewport adjustments when keyboard is visible */
    #game-canvas.keyboard-visible {
      height: calc(100vh - 280px) !important;
    }

    @media (max-width: 480px) {
      .key-button {
        padding: 15px 10px;
        font-size: 1.2rem;
        min-width: 42px;
      }

      .full-keyboard .key-button {
        padding: 12px 6px;
        font-size: 1rem;
        min-width: 32px;
        max-width: 42px;
      }

      #game-canvas.keyboard-visible {
        height: calc(100vh - 250px) !important;
      }
    }

    @media (max-width: 380px) {
      .key-button {
        padding: 12px 8px;
        font-size: 1rem;
        min-width: 38px;
        gap: 6px;
      }

      .full-keyboard .key-button {
        padding: 10px 4px;
        font-size: 0.9rem;
        min-width: 28px;
        max-width: 38px;
      }
    }

    /* Responsive - Mobile First */
    @media (max-width: 1024px) {
      #back-btn {
        top: 15px;
        left: 15px;
        padding: 10px 20px;
        font-size: 0.7rem;
      }

      .game-title {
        font-size: 4rem;
        letter-spacing: 10px;
      }

      .game-subtitle {
        font-size: 0.95rem;
      }

      .stat-value {
        font-size: 1.3rem;
      }

      .stat-label {
        font-size: 0.7rem;
      }
    }

    @media (max-width: 768px) {
      .game-title {
        font-size: 3rem;
        letter-spacing: 8px;
      }

      .game-subtitle {
        font-size: 0.85rem;
        letter-spacing: 4px;
      }

      .game-instruction {
        font-size: 0.8rem;
        letter-spacing: 2px;
      }

      #stats-hud {
        top: 15px;
        gap: 30px;
        flex-wrap: wrap;
        justify-content: center;
      }

      .stat-value {
        font-size: 1.1rem;
      }

      .stat-label {
        font-size: 0.65rem;
      }

      #key-indicator {
        gap: 20px;
        bottom: 240px; /* Make room for mobile keyboard */
        flex-wrap: wrap;
        justify-content: center;
      }

      /* Adjust when keyboard is visible */
      #game-canvas.keyboard-visible ~ #game-hud #key-indicator {
        bottom: 260px;
      }

      .key-display {
        font-size: 1.5rem;
        padding: 12px 18px;
        min-width: 60px;
      }

      .player-label {
        font-size: 0.65rem;
        letter-spacing: 2px;
      }

      .win-title {
        font-size: 3rem;
        letter-spacing: 8px;
      }

      .win-stats {
        font-size: 1rem;
      }

      .win-restart {
        font-size: 0.8rem;
      }

      #countdown-display {
        font-size: 6rem;
      }

      #back-btn {
        padding: 8px 16px;
        font-size: 0.65rem;
      }
    }

    @media (max-width: 480px) {
      .game-title {
        font-size: 2.5rem;
        letter-spacing: 6px;
      }

      .game-subtitle {
        font-size: 0.75rem;
        letter-spacing: 3px;
      }

      .game-instruction {
        font-size: 0.7rem;
      }

      #stats-hud {
        gap: 15px;
      }

      .stat-value {
        font-size: 1rem;
      }

      .stat-label {
        font-size: 0.6rem;
      }

      #key-indicator {
        gap: 15px;
        bottom: 220px; /* More room for mobile keyboard */
      }

      #game-canvas.keyboard-visible ~ #game-hud #key-indicator {
        bottom: 240px;
      }

      .key-display {
        font-size: 1.3rem;
        padding: 10px 15px;
        min-width: 50px;
      }

      .player-label {
        font-size: 0.6rem;
      }

      .win-title {
        font-size: 2.5rem;
        letter-spacing: 6px;
      }

      .win-stats {
        font-size: 0.9rem;
      }

      .win-restart {
        font-size: 0.7rem;
      }

      #countdown-display {
        font-size: 5rem;
      }

      .touch-button {
        padding: 20px 40px;
        font-size: 1.5rem;
        min-width: 180px;
      }

      #back-btn {
        padding: 6px 12px;
        font-size: 0.6rem;
        letter-spacing: 2px;
      }

      #back-btn svg {
        width: 12px;
        height: 12px;
      }
    }

    /* Landscape mode adjustments */
    @media (max-width: 900px) and (orientation: landscape) {
      .game-title {
        font-size: 2rem;
        letter-spacing: 6px;
      }

      .game-subtitle {
        font-size: 0.7rem;
        margin-bottom: 1.5rem;
      }

      #stats-hud {
        top: 10px;
        gap: 20px;
      }

      #key-indicator {
        bottom: 15px;
        gap: 15px;
      }

      .touch-button {
        bottom: 15px;
        padding: 15px 35px;
        font-size: 1.3rem;
      }
    }
  </style>
</head>
<body>
  <div id="loading-overlay"></div>

  <!-- Back Button -->
  <a href="modes.html" id="back-btn" style="position: fixed; top: 30px; left: 30px; padding: 14px 28px; font-family: 'Orbitron', sans-serif; font-size: 0.8rem; font-weight: 700; letter-spacing: 3px; color: #00ffff; background: rgba(0, 0, 0, 0.8); border: 2px solid #00ffff; text-decoration: none; z-index: 500; transition: all 0.3s ease; backdrop-filter: blur(10px); text-shadow: 0 0 10px #00ffff; display: flex; align-items: center; gap: 8px;">
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" style="width: 16px; height: 16px;">
      <path d="M19 12H5M12 19l-7-7 7-7"/>
    </svg>
    BACK
  </a>
  <style>
    #back-btn:hover {
      background: rgba(0, 255, 255, 0.15);
      box-shadow: 0 0 40px rgba(0, 255, 255, 0.5);
      transform: translateX(-8px);
      border-color: #fff;
      color: #fff;
    }
    #back-btn:hover svg {
      transform: translateX(-4px);
    }
  </style>

  <canvas id="game-canvas"></canvas>

  <div id="game-hud">
    <!-- Title Card (shown in menu state) -->
    <div id="title-card" style="display: none;">
      <h1 class="game-title">POLY RACE</h1>
      <p class="game-subtitle">Type. Race. Win.</p>
      <p class="game-instruction" id="start-instruction">PRESS SPACE TO START</p>
    </div>

    <!-- Stats HUD (shown during gameplay) -->
    <div id="stats-hud" style="display: none;">
      <div class="stat-display">
        <div class="stat-label">TIME</div>
        <div class="stat-value cyan" id="time-display">0.0s</div>
      </div>
    </div>

    <!-- Countdown Display -->
    <div id="countdown-display" style="display: none;"></div>

    <!-- Key Indicators (shown during gameplay) -->
    <div id="key-indicator" style="display: none;"></div>

    <!-- Win Screen -->
    <div id="win-screen">
      <h2 class="win-title" id="win-title">PLAYER 1 WINS!</h2>
      <p class="win-stats" id="win-time">Time: 0.0s</p>
      <p class="win-stats" id="win-score">Score: 0</p>
      <p class="win-stats" id="win-combo">Max Combo: 0</p>
      <p class="win-restart" id="win-restart-text">PRESS SPACE TO RESTART</p>
    </div>
  </div>

  <!-- Mobile Touch Controls -->
  <div id="mobile-controls">
    <div class="mobile-hint" id="mobile-hint">Type to race</div>

    <!-- Home Row Keyboard (for single/double letter modes) -->
    <div class="home-row-keyboard" id="home-row-keyboard" style="display: none;">
      <!-- Keys will be dynamically generated -->
    </div>

    <!-- Full QWERTY Keyboard (for word/story modes) -->
    <div class="full-keyboard" id="full-keyboard" style="display: none;">
      <div class="keyboard-row">
        <button class="key-button" data-key="q">Q</button>
        <button class="key-button" data-key="w">W</button>
        <button class="key-button" data-key="e">E</button>
        <button class="key-button" data-key="r">R</button>
        <button class="key-button" data-key="t">T</button>
        <button class="key-button" data-key="y">Y</button>
        <button class="key-button" data-key="u">U</button>
        <button class="key-button" data-key="i">I</button>
        <button class="key-button" data-key="o">O</button>
        <button class="key-button" data-key="p">P</button>
      </div>
      <div class="keyboard-row">
        <button class="key-button" data-key="a">A</button>
        <button class="key-button" data-key="s">S</button>
        <button class="key-button" data-key="d">D</button>
        <button class="key-button" data-key="f">F</button>
        <button class="key-button" data-key="g">G</button>
        <button class="key-button" data-key="h">H</button>
        <button class="key-button" data-key="j">J</button>
        <button class="key-button" data-key="k">K</button>
        <button class="key-button" data-key="l">L</button>
      </div>
      <div class="keyboard-row">
        <button class="key-button" data-key="z">Z</button>
        <button class="key-button" data-key="x">X</button>
        <button class="key-button" data-key="c">C</button>
        <button class="key-button" data-key="v">V</button>
        <button class="key-button" data-key="b">B</button>
        <button class="key-button" data-key="n">N</button>
        <button class="key-button" data-key="m">M</button>
      </div>
      <div class="keyboard-row">
        <button class="key-button space" data-key=" ">SPACE</button>
      </div>
    </div>
  </div>

  <script>
// ============================================
// Mobile Detection & Touch Controls
// ============================================
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                 (window.innerWidth <= 768);
const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

let mobileControlsActive = isMobile || isTouchDevice;

console.log('[MOBILE] Detection:', { isMobile, isTouchDevice, mobileControlsActive });

// Setup mobile controls if needed
if (mobileControlsActive) {
  window.addEventListener('load', () => {
    const mobileControls = document.getElementById('mobile-controls');
    const homeRowKeyboard = document.getElementById('home-row-keyboard');
    const fullKeyboard = document.getElementById('full-keyboard');
    const gameCanvas = document.getElementById('game-canvas');
    const winRestartText = document.getElementById('win-restart-text');
    const startInstruction = document.getElementById('start-instruction');
    const mobileHint = document.getElementById('mobile-hint');

    if (winRestartText) {
      winRestartText.textContent = 'TAP ANYWHERE TO RESTART';
    }

    if (startInstruction) {
      startInstruction.textContent = 'TAP ANYWHERE TO START';
    }

    let currentGameType = 'letters'; // letters, double, words, story
    let homeRowKeys = [];
    let keyboardInitialized = false;

    // Detect game type from URL
    const urlParams = new URLSearchParams(window.location.search);
    const gameType = urlParams.get('type') || 'letters';
    currentGameType = gameType;

    console.log('[MOBILE] Game type:', currentGameType);

    // Generate home row keyboard for letter modes
    function generateHomeRowKeyboard() {
      if (!homeRowKeyboard) return;

      homeRowKeyboard.innerHTML = '';

      // Keys for single/double letter mode (home row + common letters)
      const keys = ['A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L'];
      homeRowKeys = keys;

      keys.forEach(key => {
        const btn = document.createElement('button');
        btn.className = 'key-button';
        btn.setAttribute('data-key', key.toLowerCase());
        btn.textContent = key;
        homeRowKeyboard.appendChild(btn);
      });

      console.log('[MOBILE] Home row keyboard generated');
    }

    // Setup keyboard based on game type
    function setupKeyboard() {
      if (keyboardInitialized) return;

      if (currentGameType === 'letters' || currentGameType === 'double') {
        // Use home row keyboard
        generateHomeRowKeyboard();
        homeRowKeyboard.style.display = 'flex';
        fullKeyboard.style.display = 'none';
        mobileHint.textContent = 'TAP THE KEYS TO TYPE';
      } else {
        // Use full keyboard for words/story
        homeRowKeyboard.style.display = 'none';
        fullKeyboard.style.display = 'flex';
        mobileHint.textContent = 'USE KEYBOARD TO TYPE';
      }

      keyboardInitialized = true;
      console.log('[MOBILE] Keyboard setup complete');
    }

    // Handle key button press
    function handleKeyPress(key) {
      const scene = game?.current_scene;
      if (!scene || scene.STATE !== "running") return;

      // Simulate key press
      const keyDownEvent = new KeyboardEvent('keydown', {
        key: key,
        code: 'Key' + key.toUpperCase(),
        bubbles: true
      });
      document.dispatchEvent(keyDownEvent);

      // Visual feedback
      const btn = document.querySelector(`[data-key="${key}"]`);
      if (btn) {
        btn.classList.add('active');
        setTimeout(() => {
          btn.classList.remove('active');
        }, 150);
      }

      // Release key after short delay
      setTimeout(() => {
        const keyUpEvent = new KeyboardEvent('keyup', {
          key: key,
          code: 'Key' + key.toUpperCase(),
          bubbles: true
        });
        document.dispatchEvent(keyUpEvent);
      }, 100);
    }

    // Highlight active key based on current letter needed
    function updateKeyboardHighlight(scene) {
      if (!scene || !scene.players || !scene.players[0]) return;

      const player = scene.players[0];
      let nextKey = '';

      if (player.isWordMode) {
        nextKey = player.nextKey[player.wordProgress];
      } else {
        nextKey = player.nextKey;
      }

      // Remove all active highlights
      document.querySelectorAll('.key-button').forEach(btn => {
        btn.classList.remove('active');
      });

      // Add active highlight to next key
      if (nextKey) {
        const btn = document.querySelector(`[data-key="${nextKey.toLowerCase()}"]`);
        if (btn) {
          btn.classList.add('active');
        }
      }
    }

    // Setup event listeners for all keys
    function setupKeyEventListeners() {
      document.querySelectorAll('.key-button').forEach(btn => {
        btn.addEventListener('touchstart', (e) => {
          e.preventDefault();
          const key = btn.getAttribute('data-key');
          handleKeyPress(key);
        });

        // Prevent default behavior
        btn.addEventListener('touchend', (e) => {
          e.preventDefault();
        });
      });
    }

    // Show mobile controls during gameplay
    function updateMobileControls(scene) {
      if (!scene || !mobileControls) return;

      if (scene.STATE === "running" && scene.players && scene.players[0]) {
        if (!keyboardInitialized) {
          setupKeyboard();
          setupKeyEventListeners();
        }

        mobileControls.classList.add('active');
        gameCanvas.classList.add('keyboard-visible');

        // Update keyboard highlight
        updateKeyboardHighlight(scene);

        // Adjust canvas size for keyboard
        adjustCanvasForKeyboard();
      } else {
        mobileControls.classList.remove('active');
        gameCanvas.classList.remove('keyboard-visible');

        // Restore canvas size
        restoreCanvasSize();
      }
    }

    // Adjust canvas rendering area when keyboard is visible
    function adjustCanvasForKeyboard() {
      const game = window.game;
      if (!game) return;

      const keyboardHeight = 280; // Height of keyboard
      const newHeight = window.innerHeight - keyboardHeight;

      if (game.H !== newHeight) {
        game.H = newHeight;
        game.canvas.height = newHeight;

        // Update scene dimensions
        const scene = game.current_scene;
        if (scene) {
          scene.world.H = newHeight;
        }

        console.log('[MOBILE] Canvas adjusted for keyboard:', newHeight);
      }
    }

    // Restore canvas to full size
    function restoreCanvasSize() {
      const game = window.game;
      if (!game) return;

      const fullHeight = window.innerHeight;

      if (game.H !== fullHeight) {
        game.H = fullHeight;
        game.canvas.height = fullHeight;

        // Update scene dimensions
        const scene = game.current_scene;
        if (scene) {
          scene.world.H = fullHeight;
        }

        console.log('[MOBILE] Canvas restored to full size:', fullHeight);
      }
    }

    // Update controls in game loop
    setInterval(() => {
      const scene = game?.current_scene;
      if (scene) {
        updateMobileControls(scene);
      }
    }, 100);

    // Handle menu/win state taps - WAIT FOR USER INTERACTION
    let canStartGame = false;

    // Wait a moment before allowing game start (prevents auto-start)
    setTimeout(() => {
      canStartGame = true;
      console.log('[MOBILE] Ready to start game');
    }, 1000);

    document.getElementById('game-canvas').addEventListener('touchstart', (e) => {
      const scene = game?.current_scene;
      if (!scene) return;

      // Only allow start if enough time has passed
      if (scene.STATE === "menu" && canStartGame) {
        e.preventDefault();
        console.log('[MOBILE] Starting countdown via tap');
        scene.startCountdown();
        canStartGame = false; // Prevent multiple taps
      } else if (scene.STATE === "win" && scene.canRestart) {
        e.preventDefault();
        console.log('[MOBILE] Restarting game via tap');
        game.startScene("PolyRace");
        canStartGame = false;
        // Re-enable after delay
        setTimeout(() => {
          canStartGame = true;
        }, 1000);
      }
    });

    console.log('[MOBILE] Controls initialized');
  });
}
  </script>

  <script>
// Fade in effect on page load
window.addEventListener('load', () => {
  const overlay = document.getElementById('loading-overlay');
  if (overlay) {
    setTimeout(() => {
      overlay.classList.add('fade-out');
      setTimeout(() => {
        overlay.remove();
      }, 800);
    }, 100);
  }
});

// ============================================
// Utility
// ============================================
const Util = {
  timeStamp() { return window.performance.now(); },
  random(min, max) { return min + Math.random() * (max - min); },
  map(a,b,c,d,e){ return (a-b)/(c-b)*(e-d)+d; },
  lerp(a,b,t){ return a + (b-a)*t; },
  linearTween(t,b,c,d){ return c*t/d + b; },
  easeInOutQuad(t,b,c,d){ t/=d/2; if(t<1)return c/2*t*t+b; t--; return -c/2*(t*(t-2)-1)+b; }
};

// ============================================
// Vector
// ============================================
class Vector {
  constructor(x=0,y=0){ this.x=x; this.y=y; }
  set(x,y){ this.x=x; this.y=y; }
  add(v){ this.x+=v.x; this.y+=v.y; }
  mult(s){ this.x*=s; this.y*=s; }
  copy(){ return new Vector(this.x,this.y); }
  mag(){ return Math.hypot(this.x,this.y); }
}

// ============================================
// Scene base
// ============================================
class Scene {
  constructor(name){ this.name=name; this.loop=true; this.init_once=false; }
  giveWorld(world){ this.world=world; this.ctx=world.ctx; }
  keyEvents(e){} init(){} render(){}
}

// ============================================
// Physics + Entity base
// ============================================
class Body {
  constructor(entity,x,y){
    this.world = entity.world;
    this.step = this.world.FPS.step;
    this.position = new Vector(x,y);
    this.velocity = new Vector(0,0);
    this.acceleration = new Vector(0,0);
    this.drag = 0.88;
  }
  applyForce(v){ this.acceleration.add(v); }
  integrate(){
    this.velocity.add(this.acceleration);
    this.velocity.mult(this.drag);
    const v = this.velocity.copy(); v.mult(this.step);
    this.position.add(v);
    this.acceleration.set(0,0);
  }
}

class Entity {
  constructor(scene,x,y){
    this.scene=scene; this.world=scene.world; this.ctx=this.world.ctx;
    this.body=new Body(this,x,y);
  }
  update(){} draw(){} render(){ this.update(); this.draw(); }
}

// ============================================
// Particle System
// ============================================
class Particle {
  constructor(x, y, color, vx, vy) {
    this.x = x;
    this.y = y;
    this.color = color;
    this.vx = vx;
    this.vy = vy;
    this.life = 1;
    this.size = Util.random(2, 6);
  }
  update() {
    this.x += this.vx;
    this.y += this.vy;
    this.vy += 0.2;
    this.life -= 0.02;
  }
  draw(ctx) {
    if (this.life <= 0) return;
    ctx.save();
    ctx.globalAlpha = this.life;
    ctx.fillStyle = this.color;
    ctx.shadowColor = this.color;
    ctx.shadowBlur = 15;
    ctx.fillRect(this.x, this.y, this.size, this.size);
    ctx.restore();
  }
}

// ============================================
// Runner (player) with detailed poly style
// ============================================
class Runner extends Entity {
  constructor(scene,x,y,color,keySet,scale=1.5,playerNum=1){
    super(scene,x,y);
    this.color=color;
    this.keySet=keySet;
    this.scale=scale;
    this.playerNum=playerNum;
    this.nextKey=this.getNewKey();
    this.keyPressed=false;
    this.lastKey=null;
    this.startX=x;
    this.popAlpha=0;
    this.score=0;
    this.combo=0;
    this.maxCombo=0;
    this.wrongKeyPenalty=0;
    this.particles = [];
    this.lastKeyTime=0;
    this.keySpeed=0;
    this.progressPercent=0;
    this.animTime=0;

    // Word mode tracking
    this.wordProgress=0;
    this.isWordMode = this.keySet.length > 10;

    // Champion status
    this.hasChampionStatus = false;

    // Finish tracking (for multiplayer)
    this.hasFinished = false;
  }

  getNewKey(){
    let newKey;
    do {
      const randomIndex=Math.floor(Util.random(0,this.keySet.length));
      newKey = this.keySet[randomIndex];
    } while(newKey === this.lastKey && this.keySet.length > 1);
    return newKey;
  }

  checkKeyPress(){
    const keys=this.world.keys;
    const now = Date.now();

    if(this.isWordMode){
      const currentChar = this.nextKey[this.wordProgress];

      if(keys[currentChar] && !this.keyPressed){
        this.keyPressed=true;
        this.lastKey=currentChar;

        const timeSinceLastKey = now - this.lastKeyTime;
        this.keySpeed = timeSinceLastKey;
        this.lastKeyTime = now;

        let forceMultiplier = 1;
        if(timeSinceLastKey < 300) forceMultiplier = 1.3;
        else if(timeSinceLastKey < 500) forceMultiplier = 1.15;

        this.body.applyForce(new Vector(38 * forceMultiplier, 0));
        this.popAlpha=1;
        this.score+=10;
        this.combo++;
        if(this.combo > this.maxCombo) this.maxCombo = this.combo;

        this.spawnParticles(12);
        this.playBeep(440 + this.combo * 50);

        this.wordProgress++;

        if(this.wordProgress >= this.nextKey.length){
          this.wordProgress = 0;
        }
      }

      if(!this.keyPressed && this.scene.STATE==="running"){
        for(let i = 97; i <= 122; i++){
          const char = String.fromCharCode(i);
          if(keys[char] && char !== currentChar){
            this.wrongKeyPenalty = 10;
            this.combo = 0;
            this.playBeep(200);
            break;
          }
        }
      }

      if(this.keyPressed && !keys[this.lastKey]){
        this.keyPressed=false;
        if(this.wordProgress === 0){
          this.nextKey=this.getNewKey();
        }
      }
    } else {
      if(keys[this.nextKey] && !this.keyPressed){
        this.keyPressed=true;
        this.lastKey=this.nextKey;

        const timeSinceLastKey = now - this.lastKeyTime;
        this.keySpeed = timeSinceLastKey;
        this.lastKeyTime = now;

        let forceMultiplier = 1;
        if(timeSinceLastKey < 300) forceMultiplier = 1.3;
        else if(timeSinceLastKey < 500) forceMultiplier = 1.15;

        this.body.applyForce(new Vector(38 * forceMultiplier, 0));
        this.popAlpha=1;
        this.score+=10;
        this.combo++;
        if(this.combo > this.maxCombo) this.maxCombo = this.combo;

        this.spawnParticles(12);
        this.playBeep(440 + this.combo * 50);
      }

      if(!this.keyPressed && this.scene.STATE==="running"){
        for(let key of this.keySet){
          if(keys[key] && key !== this.nextKey){
            this.wrongKeyPenalty = 10;
            this.combo = 0;
            this.playBeep(200);
            break;
          }
        }
      }

      if(this.keyPressed && !keys[this.lastKey]){
        this.keyPressed=false;
        this.nextKey=this.getNewKey();
      }
    }
  }

  playBeep(freq) {
    if(!this.world.audioCtx) return;
    const osc = this.world.audioCtx.createOscillator();
    const gain = this.world.audioCtx.createGain();
    osc.connect(gain);
    gain.connect(this.world.audioCtx.destination);
    osc.frequency.value = freq;
    gain.gain.value = 0.1;
    osc.start();
    gain.gain.exponentialRampToValueAtTime(0.01, this.world.audioCtx.currentTime + 0.1);
    osc.stop(this.world.audioCtx.currentTime + 0.1);
  }

  spawnParticles(count) {
    for(let i = 0; i < count; i++) {
      const angle = Util.random(0, Math.PI * 2);
      const speed = Util.random(2, 8);
      this.particles.push(new Particle(
        this.body.position.x,
        this.body.position.y,
        this.color,
        Math.cos(angle) * speed,
        Math.sin(angle) * speed - 3
      ));
    }
  }

  checkWin(){
    const progress = this.body.position.x - this.startX;
    const target = this.scene.raceDistancePixels;
    this.progressPercent = Math.min(100, (progress / target) * 100);

    if(progress >= target && !this.hasFinished){
      this.hasFinished = true; // Prevent multiple finish emissions

      this.scene.STATE="win";
      this.scene.winner=this.scene.players.indexOf(this);
      this.scene.winnerStats = {
        score: this.score,
        maxCombo: this.maxCombo
      };

      // Emit finish event in online mode (handled by multiplayer script)
      if(this.scene.selectedMode === "online" && this.playerNum === 1) {
        console.log("[MULTIPLAYER] Local player finished!");
        // The socket emit is handled in the multiplayer script section
        if(window.multiplayerSocket) {
          window.multiplayerSocket.emit("player:finished");
        }
      }
    }
  }

  update(){
    this.body.integrate();
    if(this.popAlpha>0) this.popAlpha-=0.05;
    if(this.wrongKeyPenalty>0) this.wrongKeyPenalty-=0.3;
    if(this.body.velocity.x > 0.5) this.animTime += 0.15;

    this.particles = this.particles.filter(p => p.life > 0);
    this.particles.forEach(p => p.update());
  }

  poly(points, fill, stroke = null, lineWidth = 0) {
    const ctx = this.ctx;
    ctx.beginPath();
    ctx.moveTo(points[0].x, points[0].y);
    for (let i = 1; i < points.length; i++) {
      ctx.lineTo(points[i].x, points[i].y);
    }
    ctx.closePath();
    ctx.fillStyle = fill;
    ctx.fill();
    if (stroke) {
      ctx.strokeStyle = stroke;
      ctx.lineWidth = lineWidth;
      ctx.stroke();
    }
  }

  drawDetailedRunner(x, y, phase) {
    const ctx = this.ctx;
    const isAirborne = phase > 0.36 && phase < 0.86;
    const airLift = isAirborne ? Math.sin((phase - 0.36) / 0.5 * Math.PI) * 8 : 0;

    const legSwing = Math.sin(phase * Math.PI * 2) * 35;
    const legOpp = Math.sin(phase * Math.PI * 2 + Math.PI) * 35;

    const armSwing = Math.sin(phase * Math.PI * 2 + Math.PI) * 40;
    const armOpp = Math.sin(phase * Math.PI * 2) * 40;

    const lean = 18;
    const bob = Math.sin(phase * Math.PI * 2) * 3;

    const S = this.scale;
    y = y + bob - airLift;

    const torsoW = 24 * S;
    const torsoH = 42 * S;
    const headW = 20 * S;
    const headH = 24 * S;

    const torsoTop = y - torsoH - 12;
    const torsoBot = y - 12;

    const main = this.color;
    const light = this.lightenColor(this.color, 30);
    const dark = this.darkenColor(this.color, 30);
    const shade = this.darkenColor(this.color, 50);

    // Champion cape (drawn behind everything)
    if(this.hasChampionStatus){
      this.drawCape(ctx, x + lean, torsoTop + 8, phase, S);
    }

    // Draw back limbs
    this.drawLeg(ctx, x, torsoBot, legOpp - 10, -8, dark, shade, true, S);
    this.drawArm(ctx, x + lean, torsoTop + 14, armOpp - 35, -14, dark, shade, true, S);

    // Torso
    this.poly([
      {x: x - torsoW/2 + lean, y: torsoTop},
      {x: x + torsoW/2 + lean, y: torsoTop},
      {x: x + torsoW/2 - 2, y: torsoBot},
      {x: x - torsoW/2 - 2, y: torsoBot}
    ], main);

    this.poly([
      {x: x + torsoW/2 + lean, y: torsoTop},
      {x: x + torsoW/2 + lean + 10, y: torsoTop + 6},
      {x: x + torsoW/2 + 8, y: torsoBot + 6},
      {x: x + torsoW/2 - 2, y: torsoBot}
    ], dark);

    // Head
    const headX = x + lean + 10;
    const headY = torsoTop - headH - 2;

    this.poly([
      {x: headX - headW/2, y: headY + 4},
      {x: headX + headW/2, y: headY},
      {x: headX + headW/2 + 2, y: headY + headH - 4},
      {x: headX, y: headY + headH},
      {x: headX - headW/2 - 2, y: headY + headH - 4}
    ], light);

    this.poly([
      {x: headX + headW/2, y: headY},
      {x: headX + headW/2 + 12, y: headY + 4},
      {x: headX + headW/2 + 10, y: headY + headH - 2},
      {x: headX + headW/2 + 2, y: headY + headH - 4}
    ], dark);

    this.poly([
      {x: headX - headW/2, y: headY + 4},
      {x: headX + headW/2, y: headY},
      {x: headX + headW/2 + 12, y: headY + 4},
      {x: headX, y: headY + 8}
    ], main);

    // Draw front limbs
    this.drawLeg(ctx, x, torsoBot, legSwing + 10, 8, main, dark, false, S);
    this.drawArm(ctx, x + lean, torsoTop + 14, armSwing + 20, -10, main, dark, false, S);

    // Champion crown (drawn on top)
    if(this.hasChampionStatus){
      this.drawCrown(ctx, headX, headY - 12, S);
    }
  }

  drawCape(ctx, x, y, phase, S) {
    const capeFlow = Math.sin(phase * Math.PI * 2) * 15 - 20;
    const capeColor = "#ffaa00";
    const capeShadow = this.darkenColor(capeColor, 40);

    ctx.globalAlpha = 0.7;

    this.poly([
      {x: x - 8, y: y},
      {x: x + 8, y: y},
      {x: x + 12 + capeFlow, y: y + 50 * S},
      {x: x - 12 + capeFlow, y: y + 50 * S}
    ], capeColor);

    this.poly([
      {x: x + 8, y: y},
      {x: x + 8 + capeFlow/2, y: y + 25 * S},
      {x: x + 12 + capeFlow, y: y + 50 * S},
      {x: x, y: y + 45 * S}
    ], capeShadow);

    ctx.globalAlpha = 1.0;
  }

  drawCrown(ctx, x, y, S) {
    const crownColor = "#ffdd00";
    const crownShadow = this.darkenColor(crownColor, 30);

    ctx.shadowColor = crownColor;
    ctx.shadowBlur = 15;

    this.poly([
      {x: x - 12 * S, y: y + 10},
      {x: x + 12 * S, y: y + 10},
      {x: x + 10 * S, y: y},
      {x: x - 10 * S, y: y}
    ], crownColor);

    this.poly([
      {x: x - 10 * S, y: y},
      {x: x - 6 * S, y: y - 8},
      {x: x - 2 * S, y: y + 2}
    ], crownColor);

    this.poly([
      {x: x - 2 * S, y: y + 2},
      {x: x, y: y - 12},
      {x: x + 2 * S, y: y + 2}
    ], crownShadow);

    this.poly([
      {x: x + 2 * S, y: y + 2},
      {x: x + 6 * S, y: y - 8},
      {x: x + 10 * S, y: y}
    ], crownColor);

    ctx.shadowBlur = 0;
  }

  drawLeg(ctx, x, hipY, angle, offsetX, color1, color2, isBack, S) {
    const a = angle * Math.PI / 180;
    const thighLen = 30 * S;
    const shinLen = 30 * S;

    const hipX = x + offsetX;
    const kneeX = hipX + Math.sin(a) * thighLen;
    const kneeY = hipY + Math.cos(a) * thighLen;

    const shinA = a - 0.6;
    const ankleX = kneeX + Math.sin(shinA) * shinLen;
    const ankleY = kneeY + Math.cos(shinA) * shinLen;

    const legW = 11;
    const kneeW = 13;

    if (isBack) ctx.globalAlpha = 0.4;

    // Thigh
    const thighAngle = Math.atan2(kneeX - hipX, kneeY - hipY);
    const thighPerpX = Math.cos(thighAngle) * legW/2;
    const thighPerpY = -Math.sin(thighAngle) * legW/2;

    this.poly([
      {x: hipX - thighPerpX, y: hipY - thighPerpY},
      {x: hipX + thighPerpX, y: hipY + thighPerpY},
      {x: kneeX + thighPerpX, y: kneeY + thighPerpY},
      {x: kneeX - thighPerpX, y: kneeY - thighPerpY}
    ], color1);

    // Knee joint
    const kneePts = [];
    for (let i = 0; i < 6; i++) {
      const ang = (i / 6) * Math.PI * 2;
      kneePts.push({
        x: kneeX + Math.cos(ang) * kneeW/2,
        y: kneeY + Math.sin(ang) * kneeW/2
      });
    }
    this.poly(kneePts, this.lightenColor(this.color, 20));

    // Shin
    const shinAngle = Math.atan2(ankleX - kneeX, ankleY - kneeY);
    const shinPerpX = Math.cos(shinAngle) * (legW-2)/2;
    const shinPerpY = -Math.sin(shinAngle) * (legW-2)/2;

    this.poly([
      {x: kneeX - shinPerpX, y: kneeY - shinPerpY},
      {x: kneeX + shinPerpX, y: kneeY + shinPerpY},
      {x: ankleX + shinPerpX, y: ankleY + shinPerpY},
      {x: ankleX - shinPerpX, y: ankleY - shinPerpY}
    ], color2);

    // Foot
    this.poly([
      {x: ankleX - 8, y: ankleY},
      {x: ankleX + 18, y: ankleY},
      {x: ankleX + 20, y: ankleY + 10},
      {x: ankleX - 6, y: ankleY + 10}
    ], this.darkenColor(this.color, 60));

    if (isBack) ctx.globalAlpha = 1.0;
  }

  drawArm(ctx, shoulderX, shoulderY, angle, offsetX, color1, color2, isBack, S) {
    const a = angle * Math.PI / 180;
    const upperLen = 24 * S;
    const lowerLen = 22 * S;

    shoulderX = shoulderX + offsetX;
    const elbowX = shoulderX + Math.sin(a) * upperLen;
    const elbowY = shoulderY + Math.cos(a) * upperLen;

    const foreA = a + 0.8;
    const handX = elbowX + Math.sin(foreA) * lowerLen;
    const handY = elbowY + Math.cos(foreA) * lowerLen;

    const armW = 9;
    const elbowW = 11;

    if (isBack) ctx.globalAlpha = 0.4;

    // Upper arm
    const upperAngle = Math.atan2(elbowX - shoulderX, elbowY - shoulderY);
    const upperPerpX = Math.cos(upperAngle) * armW/2;
    const upperPerpY = -Math.sin(upperAngle) * armW/2;

    this.poly([
      {x: shoulderX - upperPerpX, y: shoulderY - upperPerpY},
      {x: shoulderX + upperPerpX, y: shoulderY + upperPerpY},
      {x: elbowX + upperPerpX, y: elbowY + upperPerpY},
      {x: elbowX - upperPerpX, y: elbowY - upperPerpY}
    ], color1);

    // Elbow joint
    const elbowPts = [];
    for (let i = 0; i < 6; i++) {
      const ang = (i / 6) * Math.PI * 2;
      elbowPts.push({
        x: elbowX + Math.cos(ang) * elbowW/2,
        y: elbowY + Math.sin(ang) * elbowW/2
      });
    }
    this.poly(elbowPts, this.lightenColor(this.color, 20));

    // Forearm
    const foreAngle = Math.atan2(handX - elbowX, handY - elbowY);
    const forePerpX = Math.cos(foreAngle) * (armW-2)/2;
    const forePerpY = -Math.sin(foreAngle) * (armW-2)/2;

    this.poly([
      {x: elbowX - forePerpX, y: elbowY - forePerpY},
      {x: elbowX + forePerpX, y: elbowY + forePerpY},
      {x: handX + forePerpX, y: handY + forePerpY},
      {x: handX - forePerpX, y: handY - forePerpY}
    ], color2);

    // Hand
    this.poly([
      {x: handX - 7, y: handY},
      {x: handX + 7, y: handY},
      {x: handX + 9, y: handY + 7},
      {x: handX, y: handY + 11},
      {x: handX - 9, y: handY + 7}
    ], this.lightenColor(this.color, 10));

    if (isBack) ctx.globalAlpha = 1.0;
  }

  lightenColor(color, percent) {
    const num = parseInt(color.replace("#",""), 16);
    const amt = Math.round(2.55 * percent);
    const R = Math.min(255, (num >> 16) + amt);
    const G = Math.min(255, (num >> 8 & 0x00FF) + amt);
    const B = Math.min(255, (num & 0x0000FF) + amt);
    return "#" + (0x1000000 + R*0x10000 + G*0x100 + B).toString(16).slice(1);
  }

  darkenColor(color, percent) {
    const num = parseInt(color.replace("#",""), 16);
    const amt = Math.round(2.55 * percent);
    const R = Math.max(0, (num >> 16) - amt);
    const G = Math.max(0, (num >> 8 & 0x00FF) - amt);
    const B = Math.max(0, (num & 0x0000FF) - amt);
    return "#" + (0x1000000 + R*0x10000 + G*0x100 + B).toString(16).slice(1);
  }

  drawHUD(ctx){
    // Only draw HUD for player 1 (local player) in online mode
    const scene = this.scene;
    if(scene.selectedMode === "online" && this.playerNum !== 1) {
      return; // Don't draw letters for opponents in online mode
    }

    ctx.save();
    const pos = this.body.position;

    const keyY=pos.y - 120 - Math.sin(Date.now()*0.005)*8;
    const shakeX = this.wrongKeyPenalty > 0 ? Math.sin(Date.now() * 0.5) * this.wrongKeyPenalty * 0.3 : 0;

    if(this.isWordMode){
      ctx.font="bold 48px 'Orbitron'";
      ctx.textAlign="center";

      const word = this.nextKey.toUpperCase();
      const completedPart = word.substring(0, this.wordProgress);
      const remainingPart = word.substring(this.wordProgress);

      const totalWidth = ctx.measureText(word).width;
      const completedWidth = ctx.measureText(completedPart).width;

      if(completedPart){
        ctx.fillStyle="rgba(0,255,136,0.7)";
        ctx.shadowColor="rgba(0,255,136,0.7)";
        ctx.shadowBlur=20;
        ctx.fillText(completedPart, pos.x + shakeX - totalWidth/2 + completedWidth/2, keyY);
      }

      if(remainingPart){
        ctx.fillStyle=this.wrongKeyPenalty > 0 ? "#ff0000" : this.color;
        ctx.shadowColor=this.wrongKeyPenalty > 0 ? "#ff0000" : this.color;
        ctx.shadowBlur=40;
        ctx.fillText(remainingPart, pos.x + shakeX + completedWidth - totalWidth/2 + ctx.measureText(remainingPart).width/2, keyY);
      }

      if(this.popAlpha>0){
        ctx.globalAlpha=this.popAlpha;
        ctx.font="bold 56px 'Orbitron'";
        ctx.fillStyle=this.color;
        ctx.fillText(word, pos.x, keyY);
      }
    } else {
      ctx.font="bold 52px 'Orbitron'";
      ctx.textAlign="center";
      ctx.fillStyle=this.wrongKeyPenalty > 0 ? "#ff0000" : this.color;
      ctx.shadowColor=this.wrongKeyPenalty > 0 ? "#ff0000" : this.color;
      ctx.shadowBlur=40;
      ctx.globalAlpha=0.9;
      ctx.fillText(this.nextKey.toUpperCase(), pos.x + shakeX, keyY);

      if(this.popAlpha>0){
        ctx.globalAlpha=this.popAlpha;
        ctx.font="bold 64px 'Orbitron'";
        ctx.fillText(this.nextKey.toUpperCase(), pos.x, keyY);
      }
    }

    if(this.combo > 2){
      ctx.globalAlpha=1;
      ctx.font="bold 24px 'Orbitron'";
      ctx.fillStyle=this.color;
      ctx.shadowBlur=30;
      ctx.fillText(`COMBO x${this.combo}`, pos.x, keyY - 55);
    }

    ctx.restore();
  }

  drawProgressBar(ctx){
    const barWidth = 220;
    const barHeight = 14;
    const x = this.body.position.x - barWidth/2;
    const y = this.body.position.y + 60;

    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.6)";
    ctx.fillRect(x, y, barWidth, barHeight);

    ctx.fillStyle = this.color;
    ctx.shadowColor = this.color;
    ctx.shadowBlur = 20;
    ctx.fillRect(x, y, barWidth * (this.progressPercent/100), barHeight);

    ctx.strokeStyle = this.color;
    ctx.lineWidth = 2;
    ctx.strokeRect(x, y, barWidth, barHeight);

    ctx.font="bold 11px 'Orbitron'";
    ctx.fillStyle="#ffffff";
    ctx.shadowBlur=10;
    ctx.textAlign="center";
    ctx.fillText(`${Math.floor(this.progressPercent)}%`, this.body.position.x, y + barHeight - 1);
    ctx.restore();
  }

  draw(){
    const ctx=this.world.ctx;
    const pos=this.body.position;

    // Particles
    this.particles.forEach(p => p.draw(ctx));

    // Main character with glow
    ctx.save();
    ctx.shadowColor=this.color;
    ctx.shadowBlur=30;

    const phase = (this.animTime) % 1;
    this.drawDetailedRunner(pos.x, pos.y, phase);
    ctx.restore();

    // HUD elements
    if(this.scene.STATE==="running"){
      this.drawHUD(ctx);
      this.drawProgressBar(ctx);
    }
  }
}

// ============================================
// Scene: Poly Race Typing Duel
// ============================================
const PolyRaceScene = new Scene("PolyRace");

// Word pool for word mode
PolyRaceScene.WORD_POOL = [
  'speed', 'race', 'fast', 'type', 'win', 'quick', 'rush', 'zoom', 'dash', 'run',
  'jump', 'move', 'leap', 'fly', 'bolt', 'sprint', 'chase', 'pace', 'swift', 'rapid',
  'code', 'game', 'play', 'skill', 'power', 'boost', 'track', 'score', 'goal', 'star'
];

// Double letter combinations
PolyRaceScene.DOUBLE_LETTERS = [
  'ab', 'cd', 'ef', 'gh', 'ij', 'kl', 'mn', 'op', 'qr', 'st',
  'uv', 'wx', 'yz', 'ac', 'bd', 'ce', 'df', 'eg', 'fh', 'gi',
  'hj', 'ik', 'jl', 'km', 'ln', 'mo', 'np', 'oq', 'pr', 'qs'
];

// Story mode sentences
PolyRaceScene.STORY_POOL = [
  'The quick brown fox jumps over the lazy dog.',
  'Practice makes perfect in every skill you learn.',
  'Speed and accuracy are both important.',
  'Keep your eyes on the screen and type fast.',
  'Racing against time improves your typing.',
  'Every keystroke counts in this challenge.',
  'Focus on the letters and move your fingers.',
  'Compete with friends and improve together.',
  'The faster you type, the quicker you win.',
  'Master the keyboard one race at a time.'
];

PolyRaceScene.init=function(){
  this.ctx=this.world.ctx;
  this.players=[];

  this.STATE="menu";
  this.titleFloat=0;
  this.countSeq=["READY","SET","GO!"];
  this.countIndex=0;
  this.countStart=0;
  this.winner=null;
  this.winnerStats=null;
  this.canRestart=false;
  this.raceStartTime=0;
  this.raceTime=0;

  // Read URL parameters
  const urlParams = new URLSearchParams(window.location.search);
  const urlMode = urlParams.get('mode');
  const urlRaceType = urlParams.get('race');
  const urlTypingMode = urlParams.get('type');
  const urlRoomCode = urlParams.get('room');
  const urlPlayers = urlParams.get('players');

  this.selectedMode = urlMode || "practice";
  this.gameMode = urlTypingMode || "letters";
  this.playerCount = parseInt(urlPlayers) || 2;

  // Set race distance
  if(urlRaceType === "marathon") {
    this.raceDistancePixels = 2400;
  } else {
    this.raceDistancePixels = 800;
  }

  this.atmosphereOffset=0;
  this.cameraX=0;
  this.targetCameraX=0;
  this.gridOffset=0;

  // Initialize players
  this.initPlayers();

  // Update UI
  this.updateUIState();

  // Auto-start countdown after 1.5 seconds if coming from mode selection
  if(urlMode) {
    setTimeout(() => {
      if(this.STATE === "menu") {
        this.startCountdown();
      }
    }, 1500);
  }
};

PolyRaceScene.initPlayers=function(){
  this.players=[];

  const startX = 200;
  const playerColors = ["#00ffff", "#ff00ff", "#00ff88", "#FFD700"];
  const playerKeySets = [
    ["a","s","d","f","g","h"],
    ["j","k","l","u","i","o"],
    ["q","w","e","r","t","y"],
    ["z","x","c","v","b","n"]
  ];

  // Calculate Y positions based on player count
  const getYPosition = (index, totalPlayers) => {
    if (totalPlayers === 1) {
      return this.world.H * 0.65; // Center for solo
    } else if (totalPlayers === 2) {
      return index === 0 ? this.world.H * 0.58 : this.world.H * 0.72;
    } else {
      // For 3-4 players, space them evenly
      const spacing = 0.15;
      const startY = 0.45;
      return this.world.H * (startY + (index * spacing));
    }
  };

  // Create players based on playerCount and typing mode
  for(let i = 0; i < this.playerCount; i++) {
    const color = playerColors[i];
    const yPos = getYPosition(i, this.playerCount);
    let keySet;

    // Determine key set based on typing mode
    if(this.gameMode === "letters") {
      // Single letter mode - use individual keys
      keySet = playerKeySets[i];
    } else if(this.gameMode === "double") {
      // Double letter mode - use two-letter combinations
      keySet = this.DOUBLE_LETTERS;
    } else if(this.gameMode === "words") {
      // Words mode - use word pool
      keySet = this.WORD_POOL;
    } else if(this.gameMode === "story") {
      // Story mode - use sentences
      keySet = this.STORY_POOL;
    } else if(this.gameMode === "custom") {
      // Custom mode - for now use words (could be expanded)
      keySet = this.WORD_POOL;
    } else {
      // Default to letters
      keySet = playerKeySets[i];
    }

    const player = new Runner(this, startX, yPos, color, keySet, 1.6, i + 1);
    this.players.push(player);
  }
};

PolyRaceScene.updateUIState=function(){
  const titleCard = document.getElementById('title-card');
  const statsHud = document.getElementById('stats-hud');
  const keyIndicator = document.getElementById('key-indicator');
  const winScreen = document.getElementById('win-screen');

  if(this.STATE === "menu"){
    titleCard.style.display = 'block';
    statsHud.style.display = 'none';
    keyIndicator.style.display = 'none';
    winScreen.classList.remove('active');
  } else if(this.STATE === "countdown" || this.STATE === "running"){
    titleCard.style.display = 'none';
    statsHud.style.display = 'flex';
    keyIndicator.style.display = 'flex';
    winScreen.classList.remove('active');
  } else if(this.STATE === "win"){
    titleCard.style.display = 'none';
    statsHud.style.display = 'none';
    keyIndicator.style.display = 'none';
    winScreen.classList.add('active');
  }
};

PolyRaceScene.updateKeyIndicator=function(){
  const indicator = document.getElementById('key-indicator');
  if(this.STATE === "running") {
    // In online mode, only show local player's key (player 1)
    const playersToShow = this.selectedMode === "online" ? [this.players[0]] : this.players;

    indicator.innerHTML = playersToShow.map((p, i) => {
      if (!p) return '';

      const actualIndex = this.selectedMode === "online" ? 0 : i;
      let displayKey;
      let isPressed;

      if(p.isWordMode) {
        displayKey = p.nextKey[p.wordProgress].toUpperCase();
        isPressed = this.world.keys[p.nextKey[p.wordProgress]];
      } else {
        displayKey = p.nextKey.toUpperCase();
        isPressed = this.world.keys[p.nextKey];
      }

      return `
        <div class="player-keys">
          <div class="player-label" style="color: ${p.color}">${this.selectedMode === "online" ? 'YOU' : 'PLAYER ' + (actualIndex+1)}</div>
          <div class="key-display ${isPressed ? 'pressed' : ''}" style="color: ${p.color}; border-color: ${p.color}">
            ${displayKey}
          </div>
        </div>
      `;
    }).join('');
  }
};

PolyRaceScene.keyEvents=function(e){
  if(e.key===" "){
    if(this.STATE==="menu"){ this.startCountdown(); }
    else if(this.STATE==="win" && this.canRestart){ this.world.startScene("PolyRace"); }
  }
  if(e.key==="Escape" && this.STATE==="running"){
    this.STATE="menu";
    this.init();
  }
};

PolyRaceScene.startCountdown=function(){
  this.STATE="countdown";
  this.countIndex=0;
  this.countStart=new Date();
  this.updateUIState();
};

PolyRaceScene.advanceCountdown=function(){
  this.countIndex++;
  if(this.countIndex>=this.countSeq.length){
    this.STATE="running";
    this.raceStartTime=Date.now();
    this.updateUIState();
  }
  else { this.countStart=new Date(); }
};

PolyRaceScene.updateCountdown=function(){
  if(new Date()-this.countStart>1000){ this.advanceCountdown(); }
};

PolyRaceScene.showCountdownText=function(text){
  const display = document.getElementById('countdown-display');
  display.textContent = text;
  display.style.display = 'block';
  display.classList.remove('active');

  // Force reflow to restart animation
  void display.offsetWidth;

  display.classList.add('active');

  setTimeout(() => {
    display.style.display = 'none';
    display.classList.remove('active');
  }, 1000);
};

PolyRaceScene.updateCamera=function(){
  if(this.STATE==="running"){
    const leadPlayer = this.players.reduce((lead, p) =>
      p.body.position.x > lead.body.position.x ? p : lead
    );

    this.targetCameraX = leadPlayer.body.position.x - this.world.W * 0.3;
    this.targetCameraX = Math.max(0, this.targetCameraX);

    this.cameraX += (this.targetCameraX - this.cameraX) * 0.08;
  }
};

PolyRaceScene.updatePlayers=function(){
  if(this.STATE==="running"){
    this.raceTime = ((Date.now() - this.raceStartTime) / 1000).toFixed(1);
    document.getElementById('time-display').textContent = `${this.raceTime}s`;

    this.players.forEach(p=>{
      p.checkKeyPress();
      p.checkWin();
    });
    this.updateKeyIndicator();
    this.updateCamera();
  }
  this.players.forEach(p=>p.update());
};

PolyRaceScene.renderBackground=function(){
  const ctx=this.ctx, W=this.world.W, H=this.world.H;

  // Atmospheric gradient (no need to redraw, already set in CSS)

  // Fog layers (parallax effect)
  this.atmosphereOffset += 0.002;
  for(let i = 0; i < 3; i++) {
    ctx.save();
    ctx.globalAlpha = 0.15 - i * 0.03;
    const parallaxOffset = -this.cameraX * (0.2 + i * 0.1);
    const offset = Math.sin(this.atmosphereOffset + i * 0.5) * 50;
    const grad = ctx.createRadialGradient(W/2 + offset + parallaxOffset, H * 0.3, 50, W/2 + offset + parallaxOffset, H * 0.3, 400);
    grad.addColorStop(0, "#00ffff");
    grad.addColorStop(1, "transparent");
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, W, H);
    ctx.restore();
  }

  // Apply camera transformation
  ctx.save();
  ctx.translate(-this.cameraX, 0);

  // Scrolling grid floor with perspective
  ctx.save();
  ctx.strokeStyle="rgba(0,255,255,0.2)";
  ctx.lineWidth=1.5;

  const horizonY = H * 0.4;
  const groundY = H * 0.85;
  const cell = 60;

  // Horizontal lines
  for(let i = 0; i < 20; i++){
    const t = i / 20;
    const y = horizonY + (groundY - horizonY) * (t * t);
    const alpha = 0.1 + t * 0.35;
    ctx.globalAlpha = alpha;
    ctx.beginPath();
    const lineStartX = this.cameraX - W;
    const lineEndX = this.cameraX + W * 3;
    ctx.moveTo(lineStartX, y);
    ctx.lineTo(lineEndX, y);
    ctx.stroke();
  }

  // Vertical lines with scrolling
  const gridOffset = Math.floor(this.cameraX / cell) * cell;
  for(let i = -5; i < 30; i++){
    ctx.globalAlpha = 0.25;
    ctx.beginPath();
    const baseX = gridOffset + i * cell;
    ctx.moveTo(baseX, horizonY);
    ctx.lineTo(baseX, groundY);
    ctx.stroke();
  }
  ctx.restore();

  // Speed lines
  if(this.STATE === "running"){
    ctx.save();
    ctx.strokeStyle = "rgba(0,255,255,0.15)";
    ctx.lineWidth = 2;
    for(let i = 0; i < 8; i++){
      const y = H * 0.3 + i * 60;
      const speed = (Date.now() * 0.5 + i * 100) % 1000;
      const startX = this.cameraX + W - speed;
      const endX = startX - 100;
      ctx.globalAlpha = 0.3 - (speed / 1000) * 0.3;
      ctx.beginPath();
      ctx.moveTo(startX, y);
      ctx.lineTo(endX, y);
      ctx.stroke();
    }
    ctx.restore();
  }

  // Checkered Finish Line with Perspective (3D depth) - More Faded
  const finishX = this.players[0].startX + this.raceDistancePixels;

  ctx.save();

  // Create perspective finish line banner
  const topWidth = 40;      // Narrow at horizon (top)
  const bottomWidth = 120;  // Wide at ground (bottom)
  const rows = 12;          // Number of checkered rows
  const cols = 3;           // Number of checkered columns

  // Draw checkered pattern with perspective - More faded
  for(let row = 0; row < rows; row++) {
    const t = row / rows;
    const nextT = (row + 1) / rows;

    // Y positions with perspective curve
    const y1 = horizonY + (groundY - horizonY) * (t * t);
    const y2 = horizonY + (groundY - horizonY) * (nextT * nextT);

    // Width increases as we go down (perspective)
    const width1 = topWidth + (bottomWidth - topWidth) * t;
    const width2 = topWidth + (bottomWidth - topWidth) * nextT;

    const colWidth1 = width1 / cols;
    const colWidth2 = width2 / cols;

    for(let col = 0; col < cols; col++) {
      // Alternating pattern
      const isWhite = (row + col) % 2 === 0;

      // Calculate trapezoid points for this cell
      const x1_left = finishX - width1/2 + col * colWidth1;
      const x1_right = finishX - width1/2 + (col + 1) * colWidth1;
      const x2_left = finishX - width2/2 + col * colWidth2;
      const x2_right = finishX - width2/2 + (col + 1) * colWidth2;

      // Draw trapezoid - Much more faded (reduced opacity)
      ctx.globalAlpha = 0.15 + t * 0.25; // Reduced from 0.4 + t * 0.4
      ctx.fillStyle = isWhite ? '#ffffff' : '#000000';
      ctx.beginPath();
      ctx.moveTo(x1_left, y1);
      ctx.lineTo(x1_right, y1);
      ctx.lineTo(x2_right, y2);
      ctx.lineTo(x2_left, y2);
      ctx.closePath();
      ctx.fill();
    }
  }

  // Glowing edges with perspective - More faded
  ctx.globalAlpha = 0.3; // Reduced from 0.6
  ctx.strokeStyle = '#00ffff';
  ctx.lineWidth = 2; // Reduced from 3
  ctx.shadowColor = '#00ffff';
  ctx.shadowBlur = 15; // Reduced from 25

  // Left edge
  ctx.beginPath();
  ctx.moveTo(finishX - topWidth/2, horizonY);
  ctx.lineTo(finishX - bottomWidth/2, groundY);
  ctx.stroke();

  // Right edge
  ctx.beginPath();
  ctx.moveTo(finishX + topWidth/2, horizonY);
  ctx.lineTo(finishX + bottomWidth/2, groundY);
  ctx.stroke();

  // Top edge
  ctx.globalAlpha = 0.15; // Reduced from 0.3
  ctx.lineWidth = 1.5; // Reduced from 2
  ctx.beginPath();
  ctx.moveTo(finishX - topWidth/2, horizonY);
  ctx.lineTo(finishX + topWidth/2, horizonY);
  ctx.stroke();

  // Bottom edge
  ctx.globalAlpha = 0.35; // Reduced from 0.6
  ctx.lineWidth = 3; // Reduced from 4
  ctx.beginPath();
  ctx.moveTo(finishX - bottomWidth/2, groundY);
  ctx.lineTo(finishX + bottomWidth/2, groundY);
  ctx.stroke();

  ctx.restore();

  // Restore camera transformation
  ctx.restore();
};

PolyRaceScene.showWinScreen=function(){
  if(this.STATE !== "win") return;

  const winTitle = document.getElementById('win-title');
  const winTime = document.getElementById('win-time');
  const winScore = document.getElementById('win-score');
  const winCombo = document.getElementById('win-combo');

  const winnerColor = this.players[this.winner].color;

  winTitle.textContent = `PLAYER ${this.winner + 1} WINS!`;
  winTitle.style.color = winnerColor;

  winTime.textContent = `Time: ${this.raceTime}s`;
  winScore.textContent = `Score: ${this.winnerStats.score}`;
  winCombo.textContent = `Max Combo: ${this.winnerStats.maxCombo}`;

  this.updateUIState();
  this.canRestart = true;
};

PolyRaceScene.render=function(){
  if(this.STATE==="countdown") {
    this.updateCountdown();
    if(this.countStart){
      this.showCountdownText(this.countSeq[this.countIndex]);
    }
  }

  this.updatePlayers();

  this.world.clear();
  this.renderBackground();

  // Apply camera transformation for players
  const ctx = this.ctx;
  ctx.save();
  ctx.translate(-this.cameraX, 0);
  this.players.forEach(p=>p.draw());

  // Draw usernames in online mode
  if (this.selectedMode === "online" && this.STATE === "running") {
    this.players.forEach(p => this.drawUsername(p));
  }

  ctx.restore();

  if(this.STATE === "win" && !this.canRestart){
    this.showWinScreen();
  }
};

PolyRaceScene.drawUsername=function(player){
  if (!player || !player.username) return;

  const ctx = this.ctx;
  const pos = player.body.position;

  ctx.save();

  // Position above player's head (150px higher than letters)
  const usernameY = pos.y - 180;

  // Background for better readability
  ctx.font = "bold 16px 'Orbitron'";
  ctx.textAlign = "center";
  const textWidth = ctx.measureText(player.username).width;
  const padding = 8;

  // Draw background
  ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
  ctx.fillRect(
    pos.x - textWidth/2 - padding,
    usernameY - 14,
    textWidth + padding * 2,
    22
  );

  // Draw border
  ctx.strokeStyle = player.color;
  ctx.lineWidth = 2;
  ctx.strokeRect(
    pos.x - textWidth/2 - padding,
    usernameY - 14,
    textWidth + padding * 2,
    22
  );

  // Draw username text
  ctx.fillStyle = player.color;
  ctx.shadowColor = player.color;
  ctx.shadowBlur = 10;
  ctx.fillText(player.username, pos.x, usernameY);

  ctx.restore();
};

// ============================================
// Game World
// ============================================
class GameWorld {
  constructor(){
    this.canvas=document.getElementById("game-canvas");
    this.ctx=this.canvas.getContext("2d");
    this.ctx.imageSmoothingEnabled=false;
    this.resize();
    window.addEventListener('resize',()=>this.resize());
    this.keys={};
    this.keyBuffer = {};
    document.addEventListener("keydown",e=>this.onKeyDown(e));
    document.addEventListener("keyup",e=>this.onKeyUp(e));
    this.FPS={now:0,delta:0,last:Util.timeStamp(),step:1/60};
    this.scenes={}; this.current_scene=null;

    try {
      this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    } catch(e) {
      console.log("Audio not supported");
    }
  }
  resize(){
    this.W=window.innerWidth;
    this.H=window.innerHeight;
    this.canvas.width=this.W;
    this.canvas.height=this.H;
  }
  addScene(scene){ scene.giveWorld(this); this.scenes[scene.name]=scene; }
  startScene(name){
    this.current_scene=this.scenes[name];
    if(!this.current_scene.init_once){
      this.current_scene.init();
      this.current_scene.init_once=true;
    } else {
      this.current_scene.init_once = false;
      this.current_scene.init();
      this.current_scene.init_once = true;
    }
    this.loop();
  }
  loop(){
    this.FPS.now=Util.timeStamp();
    this.FPS.delta+=Math.min(1,(this.FPS.now-this.FPS.last)/1000);
    while(this.FPS.delta>this.FPS.step){
      this.FPS.delta-=this.FPS.step;
      this.render();
    }
    this.FPS.last=this.FPS.now;
    requestAnimationFrame(()=>this.loop());
  }
  render(){ if(this.current_scene)this.current_scene.render(); }
  clear(){ this.ctx.fillStyle="#000"; this.ctx.fillRect(0,0,this.W,this.H); }
  onKeyDown(e){
    const key = e.key.toLowerCase();
    if(!this.keyBuffer[key]) {
      this.keys[key]=true;
      this.keyBuffer[key]=true;
      if(this.current_scene&&this.current_scene.keyEvents)this.current_scene.keyEvents(e);
    }
    if(['a','s','d','f','g','h','j','k','l','u','i','o',' ','Escape','1','2'].includes(e.key)){
      e.preventDefault();
    }
  }
  onKeyUp(e){
    const key = e.key.toLowerCase();
    this.keys[key]=false;
    this.keyBuffer[key]=false;
  }
}

  // ============================================
  // Start Game
  // ============================================
  const game = new GameWorld();
  game.addScene(PolyRaceScene);
  game.startScene("PolyRace");
  </script>

  <!--  Socket.IO Client Library -->
  <script src="/socket.io/socket.io.js"></script>

  <!--  IMPROVED Multiplayer Sync -->
  <script>
  const urlParams = new URLSearchParams(window.location.search);
  const mode = urlParams.get("mode");
  if (mode === "online") {
    // Connect to server
    const serverUrl = window.location.origin;
    const socket = io(serverUrl, {
      transports: ['websocket', 'polling'],
      reconnection: true
    });

    // Make socket globally accessible for game logic
    window.multiplayerSocket = socket;

    const roomCode = urlParams.get("room");
    const playerName = localStorage.getItem("playerName") || "Player" + Math.floor(Math.random() * 10000);
    let mySocketId = null;
    let myPlayerIndex = 0; // 0 or 1 based on join order
    let myColor = '#00ffff'; // Default cyan
    let opponentColor = '#ff00ff'; // Default magenta

    console.log(`[MULTIPLAYER] Connecting to ${serverUrl} for room ${roomCode}`);

    // --- Register and Join ---
    socket.on("connect", () => {
      console.log("[MULTIPLAYER] Connected:", socket.id);
      mySocketId = socket.id;

      socket.emit("player:register", { name: playerName });
      socket.emit("room:join", { roomCode });
    });

    // Get room info after joining to determine player colors
    socket.on("room:joined", (data) => {
      console.log("[MULTIPLAYER] Joined room:", data);
      if (data.room && data.room.players) {
        // Find my index in the room
        myPlayerIndex = data.room.players.findIndex(p => p.socketId === mySocketId);

        // Assign colors based on position
        const colors = ['#00ffff', '#ff00ff'];
        myColor = colors[myPlayerIndex] || '#00ffff';
        opponentColor = colors[1 - myPlayerIndex] || '#ff00ff';

        console.log(`[MULTIPLAYER] I am player ${myPlayerIndex + 1} with color ${myColor}`);
        console.log(`[MULTIPLAYER] Opponent has color ${opponentColor}`);

        // Update player colors and usernames in the scene
        const scene = game?.current_scene;
        if (scene && scene.players) {
          const myPlayer = data.room.players[myPlayerIndex];
          const opponentPlayer = data.room.players[1 - myPlayerIndex];

          if (scene.players[0] && myPlayer) {
            scene.players[0].color = myColor;
            scene.players[0].username = myPlayer.name;
          }
          if (scene.players[1] && opponentPlayer) {
            scene.players[1].color = opponentColor;
            scene.players[1].username = opponentPlayer.name;
          }
          console.log("[MULTIPLAYER] Updated player colors and usernames in scene");
        }
      }
    });

    socket.on("room:sync", (data) => {
      console.log("[MULTIPLAYER] Room sync:", data);
      if (data.room && data.room.players) {
        myPlayerIndex = data.room.players.findIndex(p => p.socketId === mySocketId);
        const colors = ['#00ffff', '#ff00ff'];
        myColor = colors[myPlayerIndex] || '#00ffff';
        opponentColor = colors[1 - myPlayerIndex] || '#ff00ff';

        // Update player colors and usernames
        const scene = game?.current_scene;
        if (scene && scene.players) {
          const myPlayer = data.room.players[myPlayerIndex];
          const opponentPlayer = data.room.players[1 - myPlayerIndex];

          if (scene.players[0] && myPlayer) {
            scene.players[0].color = myColor;
            scene.players[0].username = myPlayer.name;
          }
          if (scene.players[1] && opponentPlayer) {
            scene.players[1].color = opponentColor;
            scene.players[1].username = opponentPlayer.name;
          }
        }
      }
    });

    // --- Send live updates (60fps throttled to ~10 updates/sec) ---
    let lastUpdateTime = 0;
    const UPDATE_INTERVAL = 100; // ms

    function sendUpdate() {
      const now = Date.now();
      if (now - lastUpdateTime < UPDATE_INTERVAL) return;
      lastUpdateTime = now;

      const scene = game.current_scene;
      if (!scene || scene.STATE !== "running") return;

      const me = scene.players[0]; // Local player is always index 0
      if (!me) {
        console.warn("[SYNC] Local player not found at index 0");
        return;
      }

      const updateData = {
        position: me.body.position.x,
        progress: me.progressPercent,
        score: me.score,
        combo: me.combo,
        animTime: me.animTime,
        velocity: me.body.velocity.x
      };

      socket.emit("player:update", updateData);

      // Log send details every 60 frames (~1 second)
      if (!window.sendLogCount) window.sendLogCount = 0;
      window.sendLogCount++;
      if (window.sendLogCount % 60 === 0) {
        console.log("[SYNC] Sending update - Progress:", me.progressPercent.toFixed(1) + "%", "Position:", me.body.position.x.toFixed(0), "Score:", me.score);
      }
    }

    // Send updates on requestAnimationFrame for smooth sync
    function updateLoop() {
      sendUpdate();
      requestAnimationFrame(updateLoop);
    }
    updateLoop();

    // --- Receive server updates ---
    socket.on("game:update", (data) => {
      const scene = game.current_scene;
      if (!scene || !data.players || !mySocketId) {
        if (!scene) console.warn("[SYNC] No scene available");
        if (!data.players) console.warn("[SYNC] No player data received");
        if (!mySocketId) console.warn("[SYNC] No socketId set yet");
        return;
      }

      // Find opponent data (player that is NOT me)
      const opponentData = data.players.find(p => p.socketId !== mySocketId);
      if (!opponentData) {
        console.warn("[SYNC] No opponent data found. My ID:", mySocketId, "Players:", data.players.map(p => p.socketId));
        return;
      }

      // Update opponent (player index 1)
      const opponent = scene.players[1];
      if (!opponent) {
        console.warn("[SYNC] No opponent player object at index 1");
        return;
      }

      // Smooth interpolation for position
      const targetX = opponentData.position ?? opponent.body.position.x;
      const oldX = opponent.body.position.x;
      opponent.body.position.x += (targetX - opponent.body.position.x) * 0.3;

      // Direct update for other properties
      opponent.progressPercent = opponentData.progress ?? 0;
      opponent.score = opponentData.score ?? 0;
      opponent.combo = opponentData.combo ?? 0;

      // Sync animation
      if (opponentData.animTime !== undefined) {
        opponent.animTime = opponentData.animTime;
      }
      if (opponentData.velocity !== undefined) {
        opponent.body.velocity.x = opponentData.velocity;
      }

      // Log sync details every 60 frames (~1 second)
      if (!window.syncLogCount) window.syncLogCount = 0;
      window.syncLogCount++;
      if (window.syncLogCount % 60 === 0) {
        console.log("[SYNC] Opponent update - Progress:", opponent.progressPercent.toFixed(1) + "%", "Position:", opponent.body.position.x.toFixed(0), "Score:", opponent.score);
      }
    });

    // --- Sync Countdown ---
    socket.on("game:countdown", () => {
      const scene = game.current_scene;
      console.log("[MULTIPLAYER] Countdown event received, scene state:", scene?.STATE);

      if (scene) {
        // Force start countdown if not already started
        if (scene.STATE === "menu" || scene.STATE === "countdown") {
          console.log("[MULTIPLAYER] Starting countdown animation");
          scene.STATE = "countdown";
          scene.countIndex = 0;
          scene.countStart = new Date();
          scene.updateUIState();
        }
      }
    });

    socket.on("game:start", () => {
      const scene = game.current_scene;
      if (scene) {
        console.log("[MULTIPLAYER] Game start signal received! Starting race...");

        // Force the game to running state
        scene.STATE = "running";
        scene.raceStartTime = Date.now();
        scene.updateUIState();

        console.log("[MULTIPLAYER] Race started! Scene STATE:", scene.STATE);
        console.log("[MULTIPLAYER] Players in scene:", scene.players.length);
        console.log("[MULTIPLAYER] Player 0 (local):", scene.players[0] ? "Ready" : "Missing");
        console.log("[MULTIPLAYER] Player 1 (opponent):", scene.players[1] ? "Ready" : "Missing");
      } else {
        console.error("[MULTIPLAYER] No scene available when game:start received!");
      }
    });

    // --- Handle win state ---
    socket.on("game:finished", (data) => {
      const scene = game.current_scene;
      if (scene && scene.STATE === "running") {
        console.log("[MULTIPLAYER] Game finished!", data);
        scene.STATE = "win";

        // Determine winner index
        if (data.winner && data.winner.socketId) {
          scene.winner = data.winner.socketId === mySocketId ? 0 : 1;
        } else {
          scene.winner = 0;
        }

        scene.winnerStats = {
          score: data.winner?.score || 0,
          maxCombo: scene.players[scene.winner]?.maxCombo || 0
        };

        scene.showWinScreen();
      }
    });

    // --- Error handling ---
    socket.on("room:error", (data) => {
      console.error("[MULTIPLAYER] Room error:", data.message);
      alert("Room error: " + (data.message || "Unknown error"));
      window.location.href = "modes.html";
    });

    socket.on("disconnect", () => {
      console.log("[MULTIPLAYER] Disconnected from server");
    });

    socket.on("connect_error", (error) => {
      console.error("[MULTIPLAYER] Connection error:", error);
    });

    // Handle when someone finishes
    window.addEventListener('beforeunload', () => {
      const scene = game.current_scene;
      if (scene && scene.STATE === "running") {
        const me = scene.players[0];
        if (me && me.progressPercent >= 100) {
          socket.emit("player:finished");
        }
      }
    });
  }
  </script>

  <!-- Global online tracking (for all game modes) -->
  <script>
    // Only create background connection if NOT in online multiplayer mode
    const urlParams2 = new URLSearchParams(window.location.search);
    const gameMode = urlParams2.get("mode");

    if (gameMode !== "online") {
      // Track as online for solo/local games
      (function() {
        const serverUrl = 'https://polyracer-production.up.railway.app';

        // Generate or get stored anonymous ID
        let anonymousId = localStorage.getItem('anonymousId');
        if (!anonymousId) {
          anonymousId = 'Guest_' + Math.random().toString(36).substr(2, 9);
          localStorage.setItem('anonymousId', anonymousId);
        }

        try {
          const backgroundSocket = io(serverUrl, {
            transports: ['websocket', 'polling'],
            reconnection: true
          });

          backgroundSocket.on('connect', () => {
            console.log('[GAME] Background connection established:', backgroundSocket.id);

            // Register as a visitor
            backgroundSocket.emit('player:register', {
              name: anonymousId,
              isVisitor: true
            });
          });

          backgroundSocket.on('disconnect', () => {
            console.log('[GAME] Background disconnected');
          });

          // Cleanup on page unload
          window.addEventListener('beforeunload', () => {
            if (backgroundSocket && backgroundSocket.connected) {
              backgroundSocket.disconnect();
            }
          });

        } catch (error) {
          console.error('[GAME] Background connection failed:', error);
        }
      })();
    }
  </script>
</body>
</html>
